<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>吴恩达机器学习笔记-1</title>
    <url>/2020/10/11/1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><p>定义：Tom Mitchell (1998): A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.</p>
<p>核心要素：</p>
<ul>
<li>E：经验。eg：观察已标记好类别的图像</li>
<li>T：目的。eg：对图像进行分类</li>
<li>P：性能度量（评判指标）。eg:例如分类正确的数量</li>
</ul>
<p>包括监督学习和非监督学习：</p>
<ul>
<li>监督学习（Supervised Learning）：利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程<ul>
<li>回归（Regression）</li>
<li>分类（Classification）</li>
</ul>
</li>
<li>无监督学习（Unsupervised Learning）：根据类别未知(没有被标记)的训练样本解决模式识别中的各种问题<ul>
<li>聚类（Clustering）</li>
<li>降维：PCA和SVD（奇异值分解， Singular Value Decomposition）等</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习课程</category>
      </categories>
      <tags>
        <tag>机器学习课程</tag>
        <tag>吴恩达</tag>
      </tags>
  </entry>
  <entry>
    <title>python入门-1</title>
    <url>/2020/10/06/1/</url>
    <content><![CDATA[<p>闲来无事，随便读点书籍（凭缘分拿啦）</p>
<p>以下测试代码均在python3.7.0集成环境下运行</p>
<p>《Python3.7网络爬虫快速入门》 王启明 清华大学出版社</p>
<a id="more"></a>

<h1 id="一、-简介"><a href="#一、-简介" class="headerlink" title="一、 简介"></a>一、 简介</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h2><p>python是一种解释型、交互式、面向对象的程序设计语言</p>
<ul>
<li>解释型：开发过程中可以没有编译环节</li>
<li>交互式：开发者在开发环境中写入代码，即刻可以得到反馈结果</li>
<li>面向对象：支持代码封装成对象的面向对象的程序设计方式</li>
</ul>
<h1 id="二、-语法速览"><a href="#二、-语法速览" class="headerlink" title="二、 语法速览"></a>二、 语法速览</h1><h2 id="2-1-数据类型与变量"><a href="#2-1-数据类型与变量" class="headerlink" title="2.1 数据类型与变量"></a>2.1 数据类型与变量</h2><ul>
<li>整数和浮点数在计算机内部存储方式不同，整数运算永远正确，浮点数运算可能存在误差</li>
<li>布尔值是字母大写（True，False），1表示True，0表示False，其他数字均不表示</li>
<li>空值为None</li>
</ul>
<h2 id="2-2-运算符"><a href="#2-2-运算符" class="headerlink" title="2.2 运算符"></a>2.2 运算符</h2><ol>
<li><p>算数运算符</p>
<p>包含 + - * / % 和 ** 和 // 七种运算符</p>
<ul>
<li>/：返回的是真实结果，而不是取整结果。比如：-10/3=-3.33333</li>
<li>%：和C++效果相同，返回的值为正数。如：-10%3=2，10%-3=-2</li>
<li>**：乘方，类似pow，两个数字均可为浮点数。如：2**3=8，2**-1=0.5</li>
<li>//：返回除法的商.如：-10//3=-4，10//-3=-4</li>
</ul>
</li>
<li><p>比较运算符</p>
<p>包含 == != &lt;&gt; &gt; &lt; &gt;= &lt;=七种运算符，返回结果为布尔类型，True或False</p>
<ul>
<li>&lt;&gt;:不等，比较两个对象是否不相等</li>
</ul>
</li>
<li><p>赋值运算符</p>
<ul>
<li>=:最简单的赋值运算符，将右边的值赋给左边的变量</li>
</ul>
<p>复合运算符：</p>
<ul>
<li>赋值号前加上算数运算符，所以一共七种</li>
<li>表示将复合赋值运算符右边的值与左边变量的值经过相应的数学运算（忽略等号然后计算）再赋给左边的变量</li>
</ul>
</li>
<li><p>逻辑运算符</p>
<p>对布尔值True和False进行运算，结果仍为布尔值<br>包含 and or not（对单布尔值进行操作）</p>
</li>
<li><p>位运算符</p>
<p>将操作数按二进制位对位进行运算，再返回结果。<br>包含 &amp; | ^ ~ &lt;&lt; &gt;&gt;</p>
<ul>
<li>^:按位异或（不同则取1）</li>
<li>~：按位取反，只有一个操作数。 <strong>即一个有符号二进制数的补码形式</strong></li>
</ul>
</li>
<li><p>成员运算符</p>
<p>判断摸个之是否存在于字符串、列表、元组等制定对象中，返回结果为布尔值<br>包含 in 和 not in</p>
</li>
<li><p>身份运算符</p>
<p>用于比较两个对象的存储单元，返回结果为布尔值<br>只有is</p>
<ul>
<li>is用于判断两个变量引用对象是否为同一个</li>
<li>==用于判断变量的值是否相等</li>
</ul>
</li>
</ol>
<h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><p>包括列表、元组、字典、集合等</p>
<h3 id="2-3-1-列表"><a href="#2-3-1-列表" class="headerlink" title="2.3.1 列表"></a>2.3.1 列表</h3><p>list是Python最常用的数据类型，数据项（元素）不需要相同的数据类型，可以随时增删</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>用中括号括起来，逗号分隔不同的数据项</p>
<pre><code>list1 = [&apos;a&apos;, 1, True]</code></pre><p>下标从0开始，-1表示最后一个元素，-2表示倒数第二个。</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><ol>
<li>list.append(object)：列表末尾添加一个新的对象</li>
<li>list.extend(list)：列表末尾添加一个列表（或者多个元素）</li>
<li>list.insert(index, object)：在index位置插入指定对象</li>
</ol>
<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><ol>
<li>list.pop(?index)：不填写参数默认删除最后一个元素。返回被删除元素的值。</li>
<li>list.remove(object)：删除列表中相匹配的第一个值。没有返回，未找到会报错（用in判断）</li>
<li>del list[index]：删除对应索引的元素。无返回</li>
</ol>
<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><p>list[index] = object：根据索引直接赋值</p>
<h4 id="查"><a href="#查" class="headerlink" title="查"></a>查</h4><ol>
<li>list[index]：根据索引直接查询</li>
<li>list[start:end]：遍历索引，区域查询，左闭右开。索引值可以为负数</li>
<li>list.index(object)：返回第一个匹配object的元素索引。未找到会报错</li>
<li>max(list)和min(list)：返回列表中的最大或者最小值</li>
</ol>
<h4 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h4><ol>
<li>list.count(object)：返回某元素在列表中的出现次数。未找到返回0</li>
<li>len(list)：返回列表中的元素个数</li>
</ol>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol>
<li>list.reverse()：反转列表。无返回</li>
<li>list.sort(key = None, reverse = False)：默认对列表升序排序</li>
</ol>
<p>其中，key为排序的关键字，类似c++中的自定义cmp方法。python中多使用匿名函数lambda，实现多级列表、多级排序（逗号分隔）等</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>list.copy()：复制列表，返回值为列表内容。一般作为右值</li>
<li>list.clear()：清空列表。无返回值</li>
</ol>
<h3 id="2-3-2-元组"><a href="#2-3-2-元组" class="headerlink" title="2.3.2 元组"></a>2.3.2 元组</h3><p>Tuple也是一种特殊的符合类型列表。一旦定义后，不能改变，不能执行增删改等操作。其他操作与列表一样。</p>
<p>创建：用小括号括起来</p>
<pre><code>mood = (&apos;happy&apos;, &apos;sad&apos;)</code></pre><h3 id="2-3-3-字典"><a href="#2-3-3-字典" class="headerlink" title="2.3.3 字典"></a>2.3.3 字典</h3><p>Dict是Python中关联型的容器类型</p>
<p>创建：使用大括号（花括号）括起来，每一个元素是一对Key与Value，中间以冒号分隔</p>
<pre><code>info = {&apos;name&apos;:&apos;hehao&apos;, &apos;age&apos; : 20, &apos;sex&apos; : &apos;man&apos;}</code></pre><p>其中Key的类型只能是常量类型，不能为可变类型。Key的值不能重复。</p>
<h3 id="2-3-4-集合"><a href="#2-3-4-集合" class="headerlink" title="2.3.4 集合"></a>2.3.4 集合</h3><p>Set是无序并唯一地存放容器元素的类型。</p>
<p>创建：使用小括号将一个列表括起来（相当于字典Keys）</p>
<pre><code>shown = set([1, 2, 3])</code></pre><h4 id="集合间运算"><a href="#集合间运算" class="headerlink" title="集合间运算"></a>集合间运算</h4><ul>
<li>&amp;：求两个集合交集</li>
<li>|：求两个集合并集</li>
<li>-：求两个集合的差</li>
<li>^：求两个集合的补</li>
</ul>
<h4 id="增删"><a href="#增删" class="headerlink" title="增删"></a>增删</h4><ul>
<li>add(key)：添加集合元素</li>
<li>remove(key)：删除集合元素</li>
</ul>
<h2 id="2-4-其他语法注意点"><a href="#2-4-其他语法注意点" class="headerlink" title="2.4 其他语法注意点"></a>2.4 其他语法注意点</h2><ul>
<li><p>for中常用的range：range(start = 0, end, step = 1)是一个左闭右开的整数列表</p>
</li>
<li><p>input(?str)：可选参数str为打印在控制台的提示语句。从键盘读入输入，默认返回类型为字符串，可以用强制类型转换</p>
<pre><code>x = int(input())</code></pre></li>
<li><p>print函数的.format：类似c中的printf函数，但是形参统一用空的大括号表示，.format内排列值，逗号分隔</p>
<pre><code>print(&quot;I am a {}, {} years old now.&quot;.format(&quot;man&quot;, 20))
# 字典
info = {&apos;name&apos;:&apos;hehao&apos;, &apos;age&apos; : 20, &apos;sex&apos; : &apos;man&apos;}
print(&quot;I am a {sex}, {age} years old now.&quot;.format(**info))
# 列表
list1 = [20, &apos;boy&apos;]
print(&quot;I am a {0[1]}, {0[0]} years old now.&quot;.format(list1)) # 0表示第一个format中第一个参数，[]内为index
# 对象，类似列表，但是把[index]改为 .attribute</code></pre></li>
</ul>
<h1 id="三、-lxml与XPath语法"><a href="#三、-lxml与XPath语法" class="headerlink" title="三、 lxml与XPath语法"></a>三、 lxml与XPath语法</h1><p>lxml是一个HTML/XML的解析器，主要功能为解析和提取HTML/XML数据</p>
<p>XPath（XML Path Language， XML路径语言）是一门在XML文档中查找信息的语言，可用在XML文档中对元素和属性进行遍历</p>
<h2 id="XPath基本语法"><a href="#XPath基本语法" class="headerlink" title="XPath基本语法"></a>XPath基本语法</h2><table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">nodename</td>
<td align="center">选择此节点的所有子节点</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">从当前根节点选取</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">从文档中中选择匹配当前节点的节点</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">选择当前节点</td>
</tr>
<tr>
<td align="center">..</td>
<td align="center">选择当前节点的父节点</td>
</tr>
<tr>
<td align="center">@</td>
<td align="center">选择属性</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">通配符，选择所有元素节点与元素名</td>
</tr>
<tr>
<td align="center">@*</td>
<td align="center">选择所有属性</td>
</tr>
<tr>
<td align="center">[@attrib]</td>
<td align="center">选取具有指定属性的所有元素</td>
</tr>
<tr>
<td align="center">[@attrib=’value’]</td>
<td align="center">选取指定属性具有匹配值的所有元素</td>
</tr>
<tr>
<td align="center">[tag]</td>
<td align="center">选取所有具有指定元素的直接子节点</td>
</tr>
<tr>
<td align="center">[tag=’text’]</td>
<td align="center">选取所有具有指定元素的直接子节点</td>
</tr>
</tbody></table>
<p>使用XPath解析：</p>
<ol>
<li><p>获取HTML字符串：使用requests库的get</p>
<pre><code>import requests
url = &quot;***&quot;
headers = {&apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64)&apos;}
response = requests.get(url = url, headers = headers) # 发起连接请求
text = response.text # 返回Unicode型数据</code></pre></li>
<li><p>初始化一个XPath解析对象</p>
<pre><code>from lxml import etree
html = etree.HTML(text) # 转换为HTML格式</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>鹅厂后台开发应聘</title>
    <url>/2020/09/02/1/</url>
    <content><![CDATA[<p>想了想，还是对腾讯招聘事情纪念一下</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>8月份，在撺掇下，我还是投报了腾讯，选择的是后台开发工程师，很尴尬，当时写简历时候忘记上传个人简历，最后一页没完成……</p>
<h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><ol>
<li><p>给出一个链表，删除第K个节点<br>输入和输出是数组，于是我直接把第K个输出时候continue了</p>
</li>
<li><p>给出一个字符串，将其所有不重复的子串按照字典顺序排序，输出第K（大于1小于5）个字符串<br>注意K的范围就好，得出子串长度不超过5，然后遍历所有子串存在树中，树可以除重和自动排序，然后遍历树就行了</p>
</li>
<li><p>不记得了，难度应该不大</p>
</li>
<li><p>所有板子宽度为1，给出一组板子的高度数组，用1*1的刷子可以横着或者竖着刷，最少刷几次<br>贪心算法吧，如果当前高度大于板子宽度，代表此列要竖着刷，然后变成两个子问题；否则找出min高度，横着刷min次，再根据高度为min的点划分为多个子问题<br>题目不难，但是做的时候思绪有些多、混乱，最后思路出来了，last初值赋错了，导致只通过了55%，改后应该全过<br>贴个代码纪念</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
int res = 0;
int all[5010];
void cal(int start, int end) {
    if (start &gt;= end) return;
    int i, min = 999999999, last = start; \\这里的last当时赋值为0了
    for (i = start; i &lt; end; i++) {
        if (all[i] &gt; end - start) {
            res += 1;
            cal(start, i);
            cal(i+1, end);
            return;
        }
        if (all[i] &lt; min) min = all[i];
    }
    res += min;
    for (i = start; i &lt; end; i++) {
        all[i] = all[i] - min;
        if (all[i] == 0) {
            cal(last, i);
            last = i + 1;
        }
        if (i == end - 1) cal(last, end);
    }
}
int main() {
    int i, n;
    scanf(&quot;%d&quot;, &amp;n);
    for (i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;all[i]);
    cal(0, n);
    printf(&quot;%d&quot;, res);
    return 0;
}</code></pre></li>
<li><p>给出一个字符串，判断给定区间最少由几个回文串构成<br>没做出来，感觉是动态规划PLUS，没时间做</p>
</li>
</ol>
<p><font size = '4'>总结：</font></p>
<ol>
<li>测试通过了3.55，总体难度不高，只有第四题导入了map库，其余几题都只用了iostream</li>
<li>感觉动态规划还是没学好，需要加强</li>
<li>在遇见复杂问题时候，对于子问题的划分和问题分类，写完之后可以画出结构图，对照代码检查<br>感觉先想好再一次写好，不太适合我，容易犹豫不决，思路过多，然后乱了</li>
</ol>
<h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>笔试过后两天就收到了面试的邮件，2020-08-26，用腾讯会议，和想象中有些不一样，没有开视频，也没有现场写代码</p>
<p>面试的题目很多，总共持续了一个小时左右吧，大概分一下类，我记得的就下面了（记录的大部分是不会的）</p>
<ul>
<li>加粗是常考</li>
<li>斜体是不清楚答案，半猜的。之后要复习</li>
<li>加emmm是的说的时候有些结巴（无厘头）</li>
<li>答案是当时回答的简略版，很多错了的，特别是斜体</li>
</ul>
<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><p>（我没有上传个人简历TAT，项目经历啥的也没写完，相当于面试官对我一大半空白，后悔……）</p>
<blockquote>
<blockquote>
<blockquote>
<p>简单介绍一下自己</p>
</blockquote>
</blockquote>
</blockquote>
<p>我叫某某，来自某某大学，现在大三，就读于软件学院软件工程专业，比较喜欢啥啥啥，平常写代码喜欢用C++，对其他语言巴拉巴拉</p>
<blockquote>
<blockquote>
<blockquote>
<p>最近在看什么书</p>
</blockquote>
</blockquote>
</blockquote>
<p>《算法导论》《剑指offer》《C++Primer》（其实都没看完，看了忘了很多….）</p>
<blockquote>
<blockquote>
<blockquote>
<p>做过什么项目</p>
</blockquote>
</blockquote>
</blockquote>
<p>照着简历读了一遍…..</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><blockquote>
<blockquote>
<blockquote>
<p><strong>什么是线程？什么是进程？</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>线程是计算最小单位，进程是资源调度最小单位；线程销毁、切换消耗小，进程大；一个进程可以有多个线程；同一个进程中的线程共享内存，进程间不能之间通讯</p>
<blockquote>
<blockquote>
<blockquote>
<p><em>进程间用什么通讯</em></p>
</blockquote>
</blockquote>
</blockquote>
<p>邮箱</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><em>还有呢？</em></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>广播？</p>
<blockquote>
<blockquote>
<blockquote>
<p><em>用什么实现呢？socket还是udp</em></p>
</blockquote>
</blockquote>
</blockquote>
<p>udp吧，广播应该不需要建立连接，直接知道目标进程号就可以传输信息</p>
<blockquote>
<blockquote>
<blockquote>
<p>你知道什么是<strong><em>僵尸进程</em></strong>吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>（忘记了）僵尸进程，emm，就是说进程申请一个资源一直不释放，导致该资源一直不被调用，也无法被其他进程调用</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>是这样吗？（给我一次修改的机会）</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（我真的不记得了啊）应该是吧</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>那僵尸进程是怎么形成的呢？（深入，希望我能改答案）</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>申请一个资源，调用时间过长，导致资源不再能被调用</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>那怎么处理僵尸进程呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>结束进程，让他释放资源</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>听说过协程吗？</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>听说过，但是我没用过….</p>
<blockquote>
<blockquote>
<blockquote>
<p>使用过<strong>gdb调试程序</strong>吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>没有，因为一般做项目都是在Windows系统上，很少使用Linux系统</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>诶，我听你刚才好像有项目，那也都是在Windows做的吗？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（尴尬啊！没有发简历….尴尬尴尬尴尬，当时也是傻了，腾讯会议可以上传文档的，我上传下也好啊）</p>
<p>嗯，您说的应该是大数据开发和自动化测试吧。前者我主要负责项目统筹和数据清洗、算子设计，是在Windows下调试好能正常运行再直接上传到虚拟机。后者我主要负责是数据集方面和对算法代码理解、提出意见，也是在Windows下…</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>噢，嗯，没事（语气有些低落，失望？）</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><blockquote>
<blockquote>
<blockquote>
<p><strong>TCP的三次握手协议以及状态转换</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>SYN=1，seq=k;SYN=1,ACK=1,ack=k+1,seq=q;ACK=1,ack=q+1；不赘述了</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>为什么要三次握手不用两次？</em></strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（emmm当时复习没注意看这些，然后就说的比较乱）<br>因为如果没有第三次握手，可能客户机一直没有反应，服务器一直发送信息，造成拥塞<br>巴拉巴拉<br>抱歉，我有些紧张<br>巴拉巴拉</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>没事，还会产生什么问题呢</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>…..不知道</p>
<blockquote>
<blockquote>
<blockquote>
<p>没关系。刚刚，你提到了拥塞，说下<strong>TCP稳定性保证的因素</strong>吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>校验和；超时重传；错误重传；确认应答机制；流量管理；拥塞管理</p>
<blockquote>
<blockquote>
<blockquote>
<p><em>校验和是怎么实现的呢？</em></p>
</blockquote>
</blockquote>
</blockquote>
<p>emmm数据端转换为16进制，然后通过相加，发送方和接收方看校验和是否相同，不同就重传</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>具体呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>没有细了解过….</p>
<blockquote>
<blockquote>
<blockquote>
<p>嗯，没关系。你知道滑动窗口吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>嗯，知道。因为全双工，发送和接收数据包不冲突，多个数据包连续发送，接收方可以将数据包放在缓冲区，从缓冲区读取出数据包后再返回信息给服务器。缓冲区满了发送方就停止发送，没满就继续发送</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>HTTPS解析过程？</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>是从URL到页面吗？（不会这问题，转移到HTTP的）</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>嗯</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>八步:输入-&gt;解析IP（hosts-&gt;根服务器-&gt;域服务器-&gt;域名服务器)-&gt;TCP三次握手-&gt;HTTP请求-&gt;服务器调度资源返回-&gt;TCP四次挥手-&gt;解析HTML为DOM树，JS、CSS为语法规则树-&gt;生成渲染树，显示界面</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>你说的好像是HTTP解析，<strong>HTTPS和HTTP有什么区别呢？</strong></p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（端口使用HTTP是80，HTTPS是443，当时突然想到23端口，怀疑自己，就没说）<br>HTTPS=HTTP+SSL/TSL，有状态、加密传输、CA认证证书加密、不用重复建立TCP连接</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这个CA认证证书加密怎么实现的呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>emmmm这个，抱歉哈，没有过多了解过，只知道它有一套基于证书的独立编码-解码方式，只有拥有证书的CA才能正确编解码</p>
<h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><blockquote>
<blockquote>
<blockquote>
<p>你常用语言是C++对吧？</p>
</blockquote>
</blockquote>
</blockquote>
<p>嗯，一般喜欢用C++写代码</p>
<blockquote>
<blockquote>
<blockquote>
<p>那你讲一下<strong><em>C++编码到最后运行显示结果的过程</em></strong>吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>（这学期选修了编译原理，我知道问题是这个，但是我不记得了….）<br>emmm首先是编译器进行预处理，将include的库链接过来，然后将代码转换为中间代码，再检查中间代码，删除代码冗余部分，转换为机械码，运行得到结果后返回</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>….看你好像掌握不太熟练，给你一点提示吧，<strong><em>预处理是干什么的</em></strong>，比如#inlcude会发生什么？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>emmmm（这个我也不确定啊！不记得了）预处理就是把目标库链接过来……处理宏定义和关键字，导入表示内容，将它表示出来，保证代码可以被完全转换为机械码</p>
<blockquote>
<blockquote>
<blockquote>
<p>STL库使用过吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>嗯，使用过</p>
<blockquote>
<blockquote>
<blockquote>
<p>讲一下<strong><em>List和Vector的区别</em></strong>吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>….（我没用过list…一般直接数组，有时候Vector）Vector可以内存是可以动态增加的，它可以对数组进行copy等操作，实现了增删改查功能，巴拉巴拉，list我没怎么使用过，一般用数组，所以就说下我对Vector和数组区别的理解吧，巴拉巴拉</p>
<blockquote>
<blockquote>
<blockquote>
<p>（可能看我上一个答得不太好，就跳过了）你知道虚函数吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>嗯</p>
<blockquote>
<blockquote>
<blockquote>
<p>讲下一下<strong><em>虚函数的作用</em></strong>吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>虚函数是实现C++动态多态的基础，基类定义一个虚函数，派生类可以在它的基础上重写此函数，在调用此函数时，保证能找到正确的函数</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>虚函数怎么实现的呢？</strong></p>
</blockquote>
</blockquote>
</blockquote>
<p>通过虚函数表和虚指针</p>
<blockquote>
<blockquote>
<blockquote>
<p><em>编译器是怎么定位到真正要调用的函数</em>的呢？</p>
</blockquote>
</blockquote>
</blockquote>
<p>虚函数再重写后，虚函数表内，派生类原有的此函数会被新的函数位置覆盖</p>
<blockquote>
<blockquote>
<blockquote>
<p><em>虚函数表内存放什么呢</em>？</p>
</blockquote>
</blockquote>
</blockquote>
<p>虚函数</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>是所有虚函数吗？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>…..应该是吧，emmm，纯虚函数也要存吧….</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong><em>static关键字有什么用</em></strong>？</p>
</blockquote>
</blockquote>
</blockquote>
<p>表示目标是静态变量或者是静态函数。对于静态变量，变量只能被声明一次，而且值不能被修改（感觉自己像个傻子…怎么会不能修改值）。对于静态函数，声明了它只能在此文件内被调用，不能被其他文件调用。总的来说就是对函数作用域的一种限制和一种保护吧，保证它不被随意更改</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>那对于类中的静态函数呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>类中的静态函数只能调用类中的静态变量，不能访问实例的数据</p>
<blockquote>
<blockquote>
<blockquote>
<p><strong>内联函数</strong>知道吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>emmm嗯，inline函数，提高函数效率，</p>
<blockquote>
<blockquote>
<blockquote>
<p>那你说下<strong><em>单一实例怎么实现</em></strong>吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>（剑指offer前几十页就有的…我忘记了）emmm，用一个静态变量进行计数，每次调用构造函数之前判断静态变量是否为0，是的话就构造，不是就不构造emmmm</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>没事，别紧张，前面答得挺好的（语气还是包含一些期待的）</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（感动.jpg，可能是安慰我的，但是也感觉前面大概都答出来了一些，但是表述不太精准。感觉有希望…但是后面这两题就炸了…..）</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>单一实例要考虑什么呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>考虑同时调用，那用一个私有指针指向静态变量，保证静态变量同时只能被一个访问</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>…私有指针是这样用的吗？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（靠，果然作死了）应该是吧，私有指针的指向地址只能被自己调用</p>
<blockquote>
<blockquote>
<blockquote>
<p>还要考虑什么呢？</p>
</blockquote>
</blockquote>
</blockquote>
<p>考虑并发？</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>那怎么做呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>那就加锁吧，每次调用构造函数之前加锁，调用之后释放</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这样会不会有什么问题？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>emm会，如果同时运行到加锁的那一步，可能会死锁</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>怎么处理呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>那在加锁之前再判断一次是否有实例存在（也就是结结巴巴把书上第三种方案说出来了）</p>
<blockquote>
<blockquote>
<blockquote>
<p>说下<strong><em>strlen和sizeof</em></strong>的区别吧</p>
</blockquote>
</blockquote>
</blockquote>
<p>（没用过strlen，也没怎么用过sizeof，一般都直接写程序….我当做.length和.size()了）emmm，string类里面包含一个静态成员变量length，调用string.length时候直接调用静态成员变量值返回即可，sizeof要计算存储的开始地址到结束地址，相减后返回长度</p>
<blockquote>
<blockquote>
<blockquote>
<p>那他们返回是一样的吗？</p>
</blockquote>
</blockquote>
</blockquote>
<p>一般情况下是一样的</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>那什么情况下不一样呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>（持续作死的我….）如果String长度为0，传递过去的sizeof判断可能是一个空指针，返回为4，但是strlen判断长度是0</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>嗯？<strong><em>函数参数如果是数组怎么传递</em></strong>呢？</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>传递一个指针，指针指向数组（憨批憨批，明显传递首个元素地址）</p>
<blockquote>
<blockquote>
<blockquote>
<p>那<strong>sizeof返回</strong>长度是什么呢</p>
</blockquote>
</blockquote>
</blockquote>
<p>目标的长度，用目标结束地址减去开始地址</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>也就是说返回的是目标占用的空间大小对吧？（都明示了，我还没反应过来）</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p>嗯，是的</p>
<h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>没啥好说的，我贯彻我一惯的憨批性格，没想着挽救，自己把自己鲨了…<br>“这个工作要会什么哪些内容啊？”“虚函数之类要掌握到什么程度啊？”“计网和操作系统要知道啥啊？”</p>
<p>“谢谢，我知道我之后努力的方向了。”（我为什么要给自己下通告！！！？？？）</p>
<p><strong>我问下他啥时候出结果，对我看法，简历是否需要补传这些，不香吗？</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>果不其然挂了</p>
<p>考点总结一下：</p>
<ol>
<li>进程（僵尸，通讯），线程，协程</li>
<li>TCP三次握手四次挥手，可靠性，为什么不能少次数，和UDP区别</li>
<li>URL到界面，HTTP和HTTPS</li>
<li>C++编译原理</li>
<li>inline, sizeof, strlen等常用函数</li>
<li>虚函数，指针</li>
<li>STL库内函数deque,vector,list等的区别和基本实现</li>
<li>static, final等关键字</li>
<li>单一实例实现</li>
<li>gdb调试</li>
</ol>
<p>自我感觉：</p>
<ol>
<li>没有上传简历，憨批至极</li>
<li>有点小紧张，但是不太影响答题，感觉影响不大</li>
<li>基础有些不牢，其实面试官很多地方一直在引导我和提示我，但是我没反应过来</li>
<li>总的来说感觉还不错，答出来了0.8左右吧，答对的应该在0.6以上</li>
</ol>
<p>面试官是一个男面试官，说话很温和，给人一种很舒服的感觉，不急不慢，而且很多引导和提示，还会鼓励我（感动.jpg）</p>
<p>但是我最后两题和反问阶段，真的是毁了所有，明显感觉到面试官从有些期盼和热情，语气中逐渐透露出了失望和冰冷的模式化</p>
<p>反问阶段面试官一直问“还有吗？”现在想起来，感觉他是有所指，希望我问什么问题（应该是上传简历或者面试大概结果？）</p>
<p>自我评价我感觉还是有一点点机会过的，但是最后两题和我的反问可能让他认为我只是来试个水（我情商太低了…），于是就没有于是了</p>
<p>美团，网易加油！！！！</p>
]]></content>
      <categories>
        <category>招聘</category>
      </categories>
      <tags>
        <tag>后台开发</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop集群搭建</title>
    <url>/2020/08/07/3/</url>
    <content><![CDATA[<p>以下均在root用户权限内操作</p>
<a id="more"></a>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h3><p>进入 /etc/hostname 文件，里面内容初始为 ubuntu， 将其修改为自己喜欢的名字，如 master</p>
<p>reboot 重启电脑以生效</p>
<p>同理修改其他集群内电脑</p>
<h3 id="添加ip缓存"><a href="#添加ip缓存" class="headerlink" title="添加ip缓存"></a>添加ip缓存</h3><p>进入 /etc/hosts 文件，改动如下</p>
<pre><code>127.0.0.1    localhost
//此处本来可能有127.0.0.1 ubuntu，可以删除，也可以把ubuntu改为新主机名

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

//下面添加集群内所有计算机的ip和主机名，之后的slave统一称为slaves
192.168.42.130    master
192.168.42.129    slave1
192.168.42.128    slave2</code></pre><h3 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h3><pre><code>ssh-keygen -t rsa //生成秘钥
//接下来会提示输入秘钥存放地址、passphase段
//秘钥默认存放在 /root/.ssh下</code></pre><p>在/root/.ssh文件夹下，生成两个文件： id_rsa 和 id_rsa.pub<br>其中id_rsa中存放私钥，id_rsa.pub中存放公钥</p>
<p>同理在其他计算机中生成秘钥</p>
<h3 id="设置秘钥串"><a href="#设置秘钥串" class="headerlink" title="设置秘钥串"></a>设置秘钥串</h3><p>在 /root/.ssh 目录下新建一个文件authorized_key，将所有计算机中的公钥复制到其中，一个公钥占一行，然后把authorized_key传输给集群内所有计算机</p>
<p>使用winscp可以直接新建、打开、复制、粘贴，比较方便</p>
<p>当然，也可以使用代码，假设当前用户为master</p>
<pre><code>//将公钥写入认证钥匙串authorized中
cat id_rsa.pub &gt;&gt; authorized_keys

//用scp通过ssh传输文件，此处为从slaves处下载公钥。slaves为目标计算机，如slave1。root为服务器（目标计算机）用户名称
scp root@slaves:/root/.ssh/id_rsa.pub /root/.ssh/
//使用cat同理将所有公钥写入authorized_keys中

//将master中的authorized_keys上传到slaves中
scp /root/.ssh/authorized root@slaves:/root/.ssh</code></pre><h3 id="实现集群内免密登录"><a href="#实现集群内免密登录" class="headerlink" title="实现集群内免密登录"></a>实现集群内免密登录</h3><p>集群内免密登录已经实现，代码如下：</p>
<pre><code>ssh master
ssh slave1</code></pre><p>首次登录，会询问“是否保存与目标计算机的连接缓存”，输入“yes”就行了</p>
<p>然后在 /root/.ssh目录下，会生成一个名为 known_hosts 的文件，里面保存了连接的缓存，之后ssh连接只要秘钥、连接信息没变，就不会有其他提示信息</p>
<h2 id="hadoop搭建"><a href="#hadoop搭建" class="headerlink" title="hadoop搭建"></a>hadoop搭建</h2><h3 id="传输tar-gz包并解压"><a href="#传输tar-gz包并解压" class="headerlink" title="传输tar.gz包并解压"></a>传输tar.gz包并解压</h3><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><h3 id="增加配置文件"><a href="#增加配置文件" class="headerlink" title="增加配置文件"></a>增加配置文件</h3>]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16.04初始</title>
    <url>/2020/08/07/1/</url>
    <content><![CDATA[<p>文章针对自己的虚拟机从零开始设置，更换源，安装ssh</p>
<a id="more"></a>

<h2 id="管理员权限"><a href="#管理员权限" class="headerlink" title="管理员权限"></a>管理员权限</h2><pre><code>sudo passwd root //第一次给root用户设置密码
//输入当前用户密码以及两次确认root用户密码后设置成功
su root //切换至root用户
su hh //切换至hh用户</code></pre><h2 id="更换源"><a href="#更换源" class="headerlink" title="更换源"></a>更换源</h2><h3 id="更换apt源"><a href="#更换apt源" class="headerlink" title="更换apt源"></a>更换apt源</h3><ol>
<li><p>进入/etc/apt中，找到sources.list文件</p>
</li>
<li><p>用以下代码代替原内容（阿里云的apt源）</p>
<pre><code>deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties
deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted
deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties
deb http://mirrors.aliyun.com/ubuntu/ xenial universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe
deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse
deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties
deb http://archive.canonical.com/ubuntu xenial partner
deb-src http://archive.canonical.com/ubuntu xenial partner
deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted
deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties
deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe
deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</code></pre></li>
<li><p>使用命令 apt update 更新源</p>
</li>
</ol>
<h3 id="更换pip源"><a href="#更换pip源" class="headerlink" title="更换pip源"></a>更换pip源</h3><ol>
<li><p>在root文件目录下，新建一个目录 .pip</p>
</li>
<li><p>在/root/.pip中新建一个文件 pip.conf</p>
</li>
<li><p>在pip.conf内保存以下内容：</p>
<pre><code>[global]
trusted-host =  pypi.douban.com
index-url = http://pypi.douban.com/simple</code></pre></li>
</ol>
<p>此处使用的是豆瓣源，还有清华、阿里等源</p>
<p>由于http为非安全，所以需要加入trusted-host表示对目标url的信任</p>
<h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><h3 id="安装ssh服务"><a href="#安装ssh服务" class="headerlink" title="安装ssh服务"></a>安装ssh服务</h3><pre><code>sudo apt install openssh-server //安装ssh服务
ps -e |grep ssh //查看已启动的ssh端口</code></pre><h3 id="远程root登录"><a href="#远程root登录" class="headerlink" title="远程root登录"></a>远程root登录</h3><ol>
<li>进入/etc/ssh目录，找到配置文件 sshd_config</li>
<li>找到 # Authentication:</li>
<li>将其中的PermitRootLogin改为yes</li>
</ol>
<p>即：</p>
<pre><code># Authentication:
LoginGraceTime 120
PermitRootLogin yes 
StrictModes yes</code></pre>]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Python输出</title>
    <url>/2020/08/07/2/</url>
    <content><![CDATA[<p>设置代码编码格式</p>
<pre><code># -*- coding: UTF-8 -*-</code></pre><p><font color="red" size="3"></font> python控制台中文输出</p>
<pre><code>import sys
import io
sys.stdout=io.TextIOWrapper(sys.stdout.buffer,encoding=&apos;utf8&apos;)</code></pre>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>io</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2020/06/02/1/</url>
    <content><![CDATA[<p>6月21日要举行PAT考试了，第一次考主要为了熟悉下考场环境和编译，当然，能一次过最好啦~</p>
<p>因为数据结构忘得差不多了，所以在这里记录《数据结构》（第二版，陈越主编）的学习笔记，希望加深印象，为考研也打个基础</p>
<a id="more"></a>

<h1 id="第一章————概论"><a href="#第一章————概论" class="headerlink" title="第一章————概论"></a>第一章————概论</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol>
<li><p>提出了 数据结构的定义 有很多，最简单的是A.Shaffer的“数据结构是ADT（抽象数据类型）的物理实现”</p>
</li>
<li><p>举出打印数字的例子，比较循环和递归的效率（递归开销更大，要等待调用函数得到结果才释放内存）</p>
</li>
<li><p>用<font size="4" color="red">clock()工具</font> 展现秦九韶算法的优越性</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
clock_t start, stop; //clock_t是clock()函数返回的函数变量
//
//返回的时间单位是clock tick（时间打点），常数CLK_TCK（或CLOCK_PER_SEC)为机器时钟每秒走的时间打点数
//
double duration; //记录函数运行时间，单位为秒
int main(){
    start = clock() //开始计时
    function; //被测函数
    stop = clock() //结束计时
    duration = ((double)(stop - start))/CLK_TCK //计算运行时间
    //如果运行时间比较短，小于两次时钟打点，可以用for运行多次
    return 0;
}</code></pre></li>
</ol>
<h2 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><p><strong>数据结构 = 数据对象在计算机中的组织方式 + 对数据对象的操作</strong></p>
<p>数据对象在计算机中的组织方式：</p>
<ul>
<li>数据对象集的逻辑结构（线性、树状等）</li>
<li>数据对象集在计算机中的物理存储结构（数组、链表等）</li>
</ul>
<p><strong>抽象数据类型（Abstract Data Type）是对数据结构的抽象描述</strong></p>
<p>eg:<br>类型名称：矩阵<br>对象数据集：一个mXn矩阵三元组，每个符号代表含义<br>操作集：函数定义和返回类型</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><strong>定义：算法是一个有限指令集，接受一些输入（有些情况不需要输入），产生输出，并在一定有限步骤后终止</strong></p>
<ul>
<li>每一条指令必须有充分明确的目标，不可以有歧义</li>
<li>必须在计算机处理的范围之内</li>
<li>描述不依赖于任何一种计算机语言以及具体的实现手段</li>
</ul>
<p><strong>空间复杂度 S(n)</strong>:程序在执行时占用存储单元的长度。往往与输入数据的规模n有关。过高可能内存超限，非正常中断<br><strong>时间复杂度 T(n)</strong>:程序执行时耗费时间的长度。往往也和输入数据规模n有关，过高则效率低，运行慢</p>
<p><font size="5" color="red">P10的1.3.2算法复杂度没看完</font></p>
<h1 id="第二章————数据结构实现基础"><a href="#第二章————数据结构实现基础" class="headerlink" title="第二章————数据结构实现基础"></a>第二章————数据结构实现基础</h1>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>h5格式</title>
    <url>/2020/06/01/ckg4hvjws000pi8k6cfdk4vfm/</url>
    <content><![CDATA[<p><font color = 'red'>打印数据存在问题</font></p>
<h1 id="h5简介"><a href="#h5简介" class="headerlink" title="h5简介"></a>h5简介</h1><p>背景：CV、DL等涉及神经网络的各模型，卷积层和全连接层往往有很多神经元，训练完模型后，大量的weights的存储，可以使用h5格式存储</p>
<p>HDF（Hierarchical Data Format）<strong>层次数据格式</strong>指一种为存储和处理大容量科学数据设计的文件格式及相应库文件</p>
<a id="more"></a>
<h2 id="h5读取"><a href="#h5读取" class="headerlink" title="h5读取"></a>h5读取</h2><h3 id="神经网络读取"><a href="#神经网络读取" class="headerlink" title="神经网络读取"></a>神经网络读取</h3><p>此处顺便记录一下tf2用class定义网络</p>
<pre><code>import tensorflow as tf
from tensorflow.keras.models import Model
###方式1：使用Class###
Class model(Model):
    def __init__(self):
        super(model, self).__init__
        self.cbapd()=..... #八股定义CBAPD
    def call(self)
        x = self.cbapd(x)
        y = self.cbapd(x)

###方式2：函数返回Class###
def model(train, validate):
    x = cbapd(train)
    y = cbapd(x)
    return Model(x, y, name = &apos;model&apos;)

if __name__ == &apos;__main__&apos;:
model = model()
model.load_weights(&apos;weights.h5&apos;)</code></pre><h3 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h3><p>使用h5py库类似excel的读取（类似一个map,拥有多个key，每个key对应value)</p>
<pre><code>import h5py
import numpy as np
f = h5py.File(&apos;weights.h5&apos;, &apos;r&apos;) #用只读方式 打开h5文件
print(f.keys()) #打印所有的key
for key in f.keys():
    data = np.array(f[key])
    print(data)</code></pre><p><font color="red">不明原因报错</font><br>根据报错信息，应该是data里面有数据的类型不支持译码为ascii（可能是个例）</p>
<pre><code>运行时候  File &quot;D:\programming\python\lib\site-packages\h5py\_hl\base.py&quot;, line 137, in _e
name = name.encode(&apos;ascii&apos;)
AttributeError: &apos;slice&apos; object has no attribute &apos;encode&apos;</code></pre>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow2.0</title>
    <url>/2020/05/25/2/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>通过清理废弃的API和减少重复来简化API</li>
<li>运行后就得出结果（1是用建立图模型后用session运行）</li>
<li>使用Keras和eager execution轻松构建模型</li>
<li>标准化交换格式改进平台和跨语言部署</li>
</ul>
<h3 id="tf-keras"><a href="#tf-keras" class="headerlink" title="tf.keras"></a>tf.keras</h3><p>构建和训练模型的核心高级API（官方指定）</p>
<h3 id="Eager模式和自定义训练"><a href="#Eager模式和自定义训练" class="headerlink" title="Eager模式和自定义训练"></a>Eager模式和自定义训练</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Tensorflow2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测</title>
    <url>/2020/05/01/1/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>目标检测是在图片中对<font color="red">可变数量</font>的目标进行查找和分类</p>
<p>主要问题：</p>
<ul>
<li>目标种类和数量</li>
<li>环境的干扰</li>
<li>目标框的大小</li>
</ul>
<h3 id="目标检测-图像分类-目标分割"><a href="#目标检测-图像分类-目标分割" class="headerlink" title="目标检测-图像分类-目标分割"></a>目标检测-图像分类-目标分割</h3><ul>
<li>目标检测：检测物体位置，用矩形框标注，并标明其概率</li>
<li>图像分类：识别出一个图片包含哪些物体，并给其标注tags，再根据tag分类</li>
<li>目标分割：寻找物体具体位置。像素级别识别图像中的物体（类似红外线扫描仪效果….）<ul>
<li>语义分割：对于每一个像素点判断其属于哪一个分类</li>
<li>实例分割：在语义分割的基础上，对同一分类的目标也要标明不同</li>
</ul>
</li>
</ul>
<h3 id="历史演变"><a href="#历史演变" class="headerlink" title="历史演变"></a>历史演变</h3><table>
<thead>
<tr>
<th align="left">年份</th>
<th align="left">检测方式</th>
<th align="left">分类特征值获取</th>
<th align="left">代表技术</th>
<th align="left">改进</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2001-2012</td>
<td align="left">滑动窗口</td>
<td align="left">手工设置</td>
<td align="left">VJ，DPM</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2012-2015</td>
<td align="left">滑动窗口</td>
<td align="left">卷积神经网络提取</td>
<td align="left">Overfeat，RCNN</td>
<td align="left">特征值自动提取且有更好适应性</td>
</tr>
<tr>
<td align="left">2015-(Two-stage)</td>
<td align="left">Proposal</td>
<td align="left">卷积神经网络提取</td>
<td align="left">Fast RCNN，Faster RCNN</td>
<td align="left">提高搜索框提取目标区域的速度</td>
</tr>
<tr>
<td align="left">2015-(One-stage)</td>
<td align="left">目标框回归</td>
<td align="left">自动提取</td>
<td align="left">YOLO，SSD</td>
<td align="left">速度提升，精度稍降</td>
</tr>
</tbody></table>
<p>传统算法（2012之前）：输入——<font color="blue">候选框——特征提取——分类——</font>NMS——输出<br>深度学习（2012之后）：输入——<font color="blue">特征提取——回归——</font>NMS——输出</p>
<p>传统算法特征值提取一般关注纹理</p>
<ul>
<li>VJ的Harr特征：颜色只有黑白，采取多形状多方向得到特征值</li>
<li>HOG特征：图片灰度化后Gamma变化，计算每一个点的梯度map（xy方向量化），点组成cell得到梯度直方图，相邻多个cell组成block进行特征归一化，多个block串联并归一化</li>
<li>DPM（物体检测，HOG拓展）：梯度分为有符号和无符号，用加法代替乘法</li>
</ul>
<p>NMS（非极大值抑制算法）：同一个物体的识别，只保留识别分数最高的识别框</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>python的numpy库</title>
    <url>/2020/04/29/2/</url>
    <content><![CDATA[<p>现在很多做神经网络模拟或者其他计算量比较大的实验时，都会选择使用python语言，我认为numpy库功不可没</p>
<p>此处记录numpy库的一些基本内容和常用函数</p>
<a id="more"></a>

<h1 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NumPy(Numerical Python) 是Python 语言的一个扩展程序库，支持高维度数组与矩阵运算，并提供大量的数学函数库。</p>
<pre><code>安装还是使用pip install numpy，网速不行就使用镜像网址
引用import numpy as np，以下简称np</code></pre><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><h3 id="声明和赋值"><a href="#声明和赋值" class="headerlink" title="声明和赋值"></a>声明和赋值</h3><pre><code>NumPy库的array函数：numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></pre><p>一般只用关心object(数组或者嵌套数组)，剩下的可选内容中常用的是dtype（数组元素的数值类型）</p>
<pre><code>一维数组：a = np.array([1, 2, 3])
二维数组：a = np.array([[1, 2], [3]], dtype = &apos;float&apos;)</code></pre><p>嵌套数组一般为二维数组，可以使用a[0][0]访问</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深度学习</tag>
        <tag>numpy库</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网路向前与向后推导</title>
    <url>/2020/04/28/1/</url>
    <content><![CDATA[<p>人工智能和深度学习已经成为了当前很火的名词，在深度学习算法中，第一个接触的便是神经网络算法</p>
<p>对于一个神经网络，定义分为：输入层，隐含层，输出层 共三部分</p>
<ul>
<li>输入层：输入的数值inputs</li>
<li>隐含层：可能会有多个隐含层，只有一个隐含层则称此神经网络为“双层神经网络”，两个隐含层则称为“三层神经网络”…..</li>
<li>输出层：最终的输出outs</li>
</ul>
<a id="more"></a>

<p>对于一个神经网络，为了让其能达到我们目标要求，所以我们要先“训练”它:</p>
<ul>
<li>首先即给定输入inputs和正确的输出targer_out</li>
<li><font color="red">正向推导</font>：从输入层inputs附加权重计算得到隐含层h，再从隐含层h附加权重计算得到输出层o</li>
<li>根据得到的输出层o和预期输出target_out计算出神经网络的总误差Loss_total(以下记为E_total)</li>
<li><font color="red">反向推导</font>：根据总误差，从输出层开始调整其到第一个隐含层的权重，再逐步调整，最后调整隐含层到输入层的系数</li>
<li>经过不断循环正向推导和逆向推导，最终总误差达到一个可以接受的范围，及训练完成</li>
</ul>
<p><font color="red">训练的过程是一个递归的过程</font>，一步步调整参数大小。打有可能出现调整很多次(step很大)时候还没有达到预期，这时候要考虑调整隐含层层数和因素多少。</p>
<p>本次使用的是python做神经网络的模拟推导（没研究markdown的数学符号，就在草稿纸上写的），使用了numpy库（具体内容会在另一篇博客中）</p>
<p style = "background: PowderBlue;text-align: center;">以下为推导过程</p>

<img src="../../../img/DeepLearning/1.png">
<img src="../../../img/DeepLearning/2.png">
<img src="../../../img/DeepLearning/3.png">
<img src="../../../img/DeepLearning/4.png">

<p>图中推导为草稿部分，所以写得不太工整和详细</p>
<p style = "background: PowderBlue;text-align: center;">推导过程结束</p>


<p><font color="red">有以下几点需要注意，对于逆向推导十分重要</p>
<ol>
<li><p>对于隐含层和输出层，我们要区分其得到的结果分为两部分net和out</p>
<ul>
<li>net为网络计算出的结果,out为激活后的结果</li>
<li>同一层的一个值的out值到net值的求导，即为对sigmoid函数求导，得到dao_sigmoid(x) = sigmoid(x) * (1-sigmod(x))</li>
<li>由于正向推导用的值都是激活后的值，所以逆向推导只能由当前层的net值求导上一层out值</li>
</ul>
</li>
<li><p>掌握好链式推导法则</p>
<ul>
<li>梯度变换曲率都是E_total对权重w的求导，但是展开式却有所不同，要观察权重影响的值</li>
<li>图中的w5-w8只影响o的值。比如w5只影响o1的值，那么链式求导E_total——&gt;out_o1——&gt;net_o1——&gt;w5</li>
<li>图中的w1-w4既影响h的值，也影响o的值。比如w1影响h1的值，但同时h1又影响o1和o2的值，所以此处要把E_total分为E_o1和E_o2<br>推导：E_total——&gt;E_o1, E_o2——&gt;out_o1, out_o2——&gt;net_o1, net_o2——&gt;out_h1——&gt;net_h1——&gt;w1</font>

</li>
</ul>
</li>
</ol>
<p>代码：</p>
<pre><code>import numpy as np

def sigmoid(x):
    y = 1.0 / (1.0 + np.exp(-x))
    return y

def dao_sigmoid(x):
    y = sigmoid(x) * (1 - sigmoid(x))
    return y

if __name__ == &apos;__main__&apos;:

    #参数预设:inputs为输入，weights1为输入层到隐含层，weights2为隐含层到输出层，b为偏向，target_o为预期输出，learning_rate为学习系数
    inputs = np.array([0.05, 0.10], dtype = &apos;float&apos;)
    weights1 = np.array([[0.55, 0.75], [0.95, 0.15]], dtype = &apos;float&apos;)
    weights2 = np.array([[0.75, 0.15], [0.80, 0.60]], dtype = &apos;float&apos;)
    b = np.array([0.15, 0.80], dtype = &apos;float&apos;)
    target_o = np.array([0.01, 0.99], dtype = &apos;float&apos;)
    learning_rate = 0.5

    #设置正向推导两次。步数step从0开始
    target_step = 2
    step = 0

    while step &lt; target_step:
        print(&quot;Step :%d&quot;%(step))
        #计算隐含层h1和h2
        net_h = np.dot(inputs, weights1) + b[0]
        out_h = sigmoid(net_h)
        #计算输出层o1和o2
        net_o = np.dot(out_h, weights2) + b[1]
        out_o = sigmoid(net_o)
        #计算损失函数
        loss_total = np.sum((target_o-out_o)**2)/target_o.size
        #梯度变换曲率
        weight5, weight6 = -(target_o[0]-out_o[0]) * dao_sigmoid(net_o[0]) * out_h
        weight7, weight8 = -(target_o[1]-out_o[1]) * dao_sigmoid(net_o[1]) * out_h
        weight1, weight2 = (-(target_o[0]-out_o[0])*dao_sigmoid(net_o[0])*weights2[0][0] -(target_o[1]-out_o[1])*dao_sigmoid(net_o[1])*weights2[0][1]) * dao_sigmoid(net_h[0]) * inputs
        weight3, weight4 = (-(target_o[0]-out_o[0])*dao_sigmoid(net_o[0])*weights2[1][0] -(target_o[1]-out_o[1])*dao_sigmoid(net_o[1])*weights2[1][1]) * dao_sigmoid(net_h[1]) * inputs
        #更新参数
        weights1[0][0] = weights1[0][0] - learning_rate*weight1
        weights1[1][0] = weights1[1][0] - learning_rate*weight2
        weights1[0][1] = weights1[0][1] - learning_rate*weight3
        weights1[1][1] = weights1[1][1] - learning_rate*weight4
        weights2[0][0] = weights2[0][0] - learning_rate*weight5
        weights2[1][0] = weights2[1][0] - learning_rate*weight6
        weights2[0][1] = weights2[0][1] - learning_rate*weight7
        weights2[1][1] = weights2[1][1] - learning_rate*weight8
        #输出（就不写明了，看代码应该能明白）
        print(out_h)
        print(out_o)
        print(loss_total)
        print(weights1)
        print(weights2)
        print(&quot;\n&quot;)
        step = step+1</code></pre>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>饥荒服务器搭建</title>
    <url>/2020/03/30/1/</url>
    <content><![CDATA[<p>由于新型冠状病毒的原因，已经宅家两个多月了。缺乏自制力，所以一直在打游戏。</p>
<p>加了很多房间，但是其中大部分都会莫名其妙的卡，在观看一些自己搭建服务器的视频之后，我也跟着教程走，自己搭一个服务器试一下。</p>
<a id="more"></a>

<h2 id="Ubuntu和CentOS"><a href="#Ubuntu和CentOS" class="headerlink" title="Ubuntu和CentOS"></a>Ubuntu和CentOS</h2><p>这是我第一次使用Linux系统，首先便是了解Ubuntu和CentOS两个分支的关系和区别（不全面，只是了解的部分）</p>
<ul>
<li><p><font size="5" color="red">来源</font></p>
<ul>
<li>CentOS是Linux发行版本之一，源自Red HAT Enterprise开放源码编译而成，所以它支持rpm格式安装</li>
<li>Ubuntu基于Debian发行版和Gnome桌面环境，是一个以桌面应用为主的Linux操作系统。它不支持rpm格式安装</li>
</ul>
</li>
<li><p><font size="5" color="red">用途</font></p>
<ul>
<li>CentOS具有高度稳定性，可以代替Red HAT Enterprise作为服务器</li>
<li>Ubuntu提供用户一个开放版的社区，稳定且更新快，是由自由软件构成的操作系统</li>
</ul>
</li>
<li><p><font size="5" color="red">系统用户</font></p>
<ul>
<li>CentOS的新建用户没有管理员权限。如果需要添加管理员权限，需要到/etc/sudoers中加入用户和权限。使用”su root账户的密码”即可切换到管理员账户</li>
<li>Ubuntu的用户要使用管理员权限”sudo 命令”，第一次使用需要输入当前用户的密码。可直接使用管理员用户登录，步骤如下（都要加sudo）：<ol>
<li>“sudo passwd root”设置管理员密码，运行后会首先输入一次密码，然后确认一次。</li>
<li>“sudo vi /etc/ssh/sshd_config”系统本身是空密码管理员登录，找到其中”PermitRootLogin without-password”（无密码管理员登录）修改为”PermitRootLogin yes”（打开管理员密码登录)</li>
<li>“sudo services ssh restart”重启ssh服务，即可使用root用户登录，密码为第一步中设置的密码</li>
</ol>
</li>
</ul>
</li>
<li><p><font size="5" color="red">在线安装</font></p>
<ul>
<li>CentOS使用yum命令（后面加目标地址）</li>
<li>Ubuntu使用apt-get命令（后面加目标地址)</li>
</ul>
</li>
</ul>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>Linux系统中，命令没有大写</p>
<h3 id="输出命令echo和printf"><a href="#输出命令echo和printf" class="headerlink" title="输出命令echo和printf"></a>输出命令echo和printf</h3><ul>
<li><p>echo:</p>
<ul>
<li>“echo $value”输出变量value的值。比较常用简单输出</li>
<li>“echo -e”格式化输出后面的内容。格式化包括\t(横向制表符)，\n(换行)，\e(修改颜色,\e[0m为结束标识)等。<br>比如 echo -e “\e[31m hello world \e[0m”</li>
</ul>
</li>
<li><p>printf:</p>
<ul>
<li>使用规则和c语言差不多，但是功能没有那么强大了，主要用于awk命令，适合比较复杂的输出</li>
<li>printf自带格式化输出功能。比如\t(横向制表符)，\v（垂直制表符)，\n(换行)，%s(字符串内容)，%d(十进制整数)，%f(浮点数)<br>比如 printf “%s\t %s\t %s\t\n” [1]姓名:$name [2]性别:$sex [3]年龄:$age</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>云服务器</tag>
        <tag>Linux系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 2019 安装报错处理</title>
    <url>/2020/02/26/1/</url>
    <content><![CDATA[<p>商导快开课了，老师让提前下好SQLServer，推荐2017版本，同时承诺：“如果用2019版本完成作业直接给满分！”</p>
<p>看了下安装教程，很简单嘛(^_^) 二话不说，冲上来试试</p>

<p>前面就是设置安装路径和选择安装组件，简简单单，稳稳当当，直到…..我碰见这两兄弟TAT</p>
<a id="more"></a>

<hr>
<h2 id="报错一"><a href="#报错一" class="headerlink" title="报错一"></a>报错一</h2><p><font size="4" color="red">“以前的某个程序安装已在安装计算机上创建挂起的文件操作。安装程序前必须重新启动计算机”</font></p>
<p>重启就重启！</p>
<p>5 minutes later…</p>
<p>没用啊！</p>
<p>然后才知道，要删除注册表 “PendingFileRenameOperations” <font size="2.5" color="00AAAA">（注册表打开方式见文末）</font></p>
<p>路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</p>
<img src="../../../img/MSSQL/1.png">

<p>（图中已经删了，这个注册表应该在箭头处。它不在Session Manager目录的子文件夹内，而是在一个文件，不要在左边找）</p>
<p>然后就美滋滋安装了</p>
<h2 id="报错二"><a href="#报错二" class="headerlink" title="报错二"></a>报错二</h2><p><font size="4" color="red">“tmpBD0A.tmp: Unable to save temp file [操作已超时。]”</font></p>
<h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><p>如果安装R和Python深度学习功能，就会发现：在最后下载几个.cab文件，明明不大，但是却会卡好久…..</p>
<p>“完成但错误”，这有锤子用啊！我又用不了，就像 给我下载一个快捷方式但是不给我文件…</p>
<p>然后根据报错信息，去 C:\Program Files\Microsoft SQL Server\150\Setup Bootstrap\Log 找它的安装记录</p>
<img src="../../../img/MSSQL/2.png">

<p>报错信息总结一下：安装 SRS 和 SPO 获取资源超时（写着像是存储失败，但是同一个文件夹，其他的东西可以存进去，这个文件不能存进去，不大现实）</p>
<ul>
<li>第一个字母S取自MicroSoft的s</li>
<li>第二个字母：R代表R Studio语言，即选择安装的R语言；P代表Python语言</li>
<li>第三个字母：S代表Server，服务器端；O代表Open，也就是客户端需要的环境（安装过程需要同意的）</li>
</ul>
<p>获取资源超时，结合以前的认知，也很正常，毕竟是外网的东西，很可能连接失败什么的</p>
<h3 id="卸载组件，下载组件包"><a href="#卸载组件，下载组件包" class="headerlink" title="卸载组件，下载组件包"></a>卸载组件，下载组件包</h3><p>一般的可以尝试重复下载。但是SQLServer有点坑，“安装完成但错误”将视为组件成功安装，已安装的组件不能再次安装<br><font size="3" color="red">在修复界面修复一定会修复失败!从未成功安装过，无法修复！</font></p>
<p>首先要来<a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/install/sql-ml-component-install-without-internet-access?view=sql-server-ver15" target="_blank" rel="noopener">下载机器学习的R语言和Python包</a>，将下载的.cab文件放在一个文件夹下</p>
<p>然后要在“添加与删除”（win10叫“应用与程序”）选择卸载Microsoft SQL Server 2019</p>
<p>在卸载界面卸载R与Python组件</p>
<img src="../../../img/MSSQL/3.png">

<p>成功卸载</p>
<img src="../../../img/MSSQL/4.png">

<h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3><p>按照下载界面提示重新进入安装界面，<font size="4" color="red">断网！</font></p>
<p>按照引导会让我们选择目标文件夹，选择下载的.cab文件所在的文件夹即可</p>
<p>由于我是中文版，语言应为2052（简体中文），而下载的包语言为1033（英文），故需要<font size="3" color="red">把包的每一个名字最后的1033改为2052</font>，不然无法识别</p>
<p>然后点击下一步，等待软件安装完毕即可</p>
<img src="../../../img/MSSQL/5.png">

<p>美滋滋，安装成功！<br><img src="../../../img/MSSQL/6.png"></p>
<h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p style = "background: PowderBlue;text-align: center;">注册表管理</p>

<ul>
<li>Win + R快捷键打开“运行”界面</li>
<li>输入“regedit”并回车</li>
<li>已经到了“注册表管理”界面啦</li>
</ul>
<p style = "background: PowderBlue;text-align: center;">结束啦</p>]]></content>
      <categories>
        <category>SQLServer2019</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL Server 2019</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo撰文2</title>
    <url>/2020/02/24/2/</url>
    <content><![CDATA[<p>上文是讲的通过html直接修改文字效果，其实我们可以直接用markdown语法做其中部分处理，写起来会更为简洁<br>此文效果全部用Markdown语法，只写些常用的（就是懒！），效果图主要看字面意思+想象力（不想写太长๑Ő௰Ő๑）</p>
<a id="more"></a>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>Markdown是一种纯文本格式的标记语言（类似XML哦），利用一些简单语法就可以实现文章的排版变化，让使用者可以把更多注意力放在内容上</p>
<h2 id="一、-标题和目录"><a href="#一、-标题和目录" class="headerlink" title="一、 标题和目录"></a>一、 标题和目录</h2><p>#后<strong>加空格</strong>再加文字内容，就可以实现标题，一个警号代表一级标题，最多支持六级标题。</p>
<p>当然，没有规定预定要从一级标题开始设置，标题级别主要影响字体大小，可以按需来<br>之后，Markdown会根据标题生成目录，目录就可以精确定位到某个标题</p>
<h2 id="二、-字体设置"><a href="#二、-字体设置" class="headerlink" title="二、 字体设置"></a>二、 字体设置</h2><h3 id="1-斜体"><a href="#1-斜体" class="headerlink" title="1. 斜体"></a>1. 斜体</h3><pre><code>*要设置为斜体的内容*（不要空格,星号可以用下划线_代替）</code></pre><p><em>要设置为斜体的内容</em>（不要空格,星号可以用下划线_代替）</p>
<h3 id="2-加粗"><a href="#2-加粗" class="headerlink" title="2. 加粗"></a>2. 加粗</h3><pre><code>**要设置为加粗的内容**（不要空格,星号可以用下划线_代替）</code></pre><p><strong>要设置为加粗的内容</strong>（不要空格,星号可以用下划线_代替）</p>
<h3 id="3-斜体加粗"><a href="#3-斜体加粗" class="headerlink" title="3. 斜体加粗"></a>3. 斜体加粗</h3><pre><code>显而易见咯，用三个* 包裹起来就行了. ***要设置为斜体加粗的内容***（不要空格,星号可以用下划线_代替）</code></pre><p><strong><em>要设置为斜体加粗的内容</em></strong>（不要空格,星号可以用下划线_代替）</p>
<h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. 删除线</h3><pre><code>~~要添加删除线的内容~~（不要空格）</code></pre><p><del>要添加删除线的内容</del>（不要空格）</p>
<h2 id="三、-分隔线"><a href="#三、-分隔线" class="headerlink" title="三、 分隔线"></a>三、 分隔线</h2><pre><code>三个连续的星号、减号、下划线，都可以作为分隔行,但是这一行不能有其他的内容   ***   ---   ___</code></pre><hr>
<h2 id="四、-插入"><a href="#四、-插入" class="headerlink" title="四、 插入"></a>四、 插入</h2><h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h3><p>网上说用单引号&apos;单行代码&apos;包裹起来</p>
<p>&apos;&apos;&apos;<br>第一行代码<br>第二行代码（行数无限制）（三个引号单独占一行）<br>&apos;&apos;&apos;</p>
<p>但是好像不是很适用与md本身的一些代码，比如加粗之类的</p>
<p>于是还是用<strong>最简单直接的：在行首用tab或4个空格</strong>，申请一行不编译（可加行），背景色为深灰色，上面都是这种方式</p>
<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><p>在一段的行首，使用大于号&gt;表明一个区块，后直接加内容就可以（不用空格），一个表示一级分区（好像无分区上限）</p>
<blockquote>
<p>区块1</p>
<blockquote>
<p>区块1.1</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>区块1.1.1.1.1.1.1.1.1.1</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a>3. 超链接</h3><p><strong>超链接都是在当前界面打开，如果要在新界面打开，请使用html的a标签</strong></p>
<h4 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1 行内式"></a>3.1 行内式</h4><pre><code>[超链接名字](超链接地址 &quot;optional title（选填，鼠标移动到到超链接上显示的内容）&quot;)

eg:
[朩的微博](heoah.com &quot;他的主页&quot;)</code></pre><p><a href="heoah.com" title="他的主页">朩的微博</a></p>
<h4 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2 参考式"></a>3.2 参考式</h4><p>试了下好像没用..可能是博客或者代理用的md解析不一样吧</p>
<pre><code>[超链接名字][标号]
[标号]:超链接地址 / &quot;optional title（选填，鼠标移动到到超链接上显示的内容）&quot;

eg:
[朩的微博][1]
[1]:heoah.com</code></pre><h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4. 图片"></a>4. 图片</h3><p>和本质上和超链接是一样的，在超链接前面加个！就行了</p>
<h4 id="4-1-引用地址为网址"><a href="#4-1-引用地址为网址" class="headerlink" title="4.1 引用地址为网址"></a>4.1 引用地址为网址</h4><p>本地图片获得URL：使用图床进行存储图片。简单点说：上传你的图片给网站，网站给你分配存储空间，针对每张图片给你一个url，你直接引用url。<br>github，gitee等都有图床服务，推荐 七牛云</p>
<h4 id="4-2-引用为本地图片"><a href="#4-2-引用为本地图片" class="headerlink" title="4.2 引用为本地图片"></a>4.2 引用为本地图片</h4><p>在_config.yml设置里面post_asset_folder设置为true</p>
<p>这样在每次new post时就会在生成md文件时，同时生成一个同名的文件夹</p>
<p>安装hexo-asset-image插件:</p>
<pre><code>npm install hexo-asset-imagine --save</code></pre><p>将图片放在文件夹，命名例如1.png</p>
<pre><code>![名字（点击后出现图片，一般留空）](md文件名/图片名)

eg:
![](index/1.png)</code></pre><h2 id="五、-表"><a href="#五、-表" class="headerlink" title="五、 表"></a>五、 表</h2><h3 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h3><p><strong>在列表内容里面引用代码，用Tab或者4个空格是不阔冷滴！因为都是在行首操作</strong></p>
<h5 id="1-1-无序列表"><a href="#1-1-无序列表" class="headerlink" title="1.1 无序列表"></a>1.1 无序列表</h5><p>在行首用符号进行定义</p>
<pre><code>+ 列表内容 （加号后必须要空格）（加号可以用减号- 乘号*代替）

eg:
+ 第三行
- 第二行
* 第一行</code></pre><ul>
<li>第三行</li>
</ul>
<ul>
<li>第二行</li>
</ul>
<ul>
<li>第一行</li>
</ul>
<h4 id="1-2-有序列表"><a href="#1-2-有序列表" class="headerlink" title="1.2 有序列表"></a>1.2 有序列表</h4><p>在行首用数字加小数点定义（数字一定要为非负整数）</p>
<pre><code>标号. 列表内容（小数点后必须要空格）

eg:
1. 如果你的序号为负数，那么会认为你的有序链表到此已经结束。
4. 第一行的序号很重要，定义了你列表的开始序号
8. 后面行的序号都是根据第一行数字递增1得到的</code></pre><ol>
<li>如果你的序号为负数，那么会认为你的有序链表到此已经结束。</li>
<li>第一行的序号很重要，定义了你列表的开始序号</li>
<li>后面行的序号都是根据第一行数字递增1得到的</li>
</ol>
<h4 id="1-3-组合列表"><a href="#1-3-组合列表" class="headerlink" title="1.3 组合列表"></a>1.3 组合列表</h4><p>也可以成为 列表嵌套</p>
<p>有序列表和无序列表可以随意组合嵌套，上一级和下一级之间用三个空格区别</p>
<pre><code>eg:
+ 一级无序
   1. 二级有序
+ 一级无序
   + 二级无序
1. 一级有序
   + 二级无序
2. 一级有序
   1. 二级有序</code></pre><ul>
<li>一级无序<ol>
<li>二级有序</li>
<li>二级有序</li>
</ol>
</li>
<li>一级无序<ul>
<li>二级无序</li>
<li>二级无序</li>
</ul>
</li>
</ul>
<ol>
<li>一级有序<ul>
<li>二级无序</li>
</ul>
</li>
<li>一级有序<ol>
<li>二级有序</li>
</ol>
</li>
</ol>
<h3 id="2-表格"><a href="#2-表格" class="headerlink" title="2. 表格"></a>2. 表格</h3><pre><code>表头|表头|表头        （自定义列数都可以）
:-|:-:|-:            （ - 表示内容）（：表示对齐方式，左边代表左对齐，右边代表右对齐，两边都有表示居中对齐）
内容|内容|内容

eg:
姓名|性别|年龄
:-|:-:|-:
张三|男|15
李四|女|16
王五|男|17</code></pre><table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">性别</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td align="center">男</td>
<td align="right">15</td>
</tr>
<tr>
<td align="left">李四</td>
<td align="center">女</td>
<td align="right">16</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="center">男</td>
<td align="right">17</td>
</tr>
</tbody></table>
<h2 id="六、-数学公式"><a href="#六、-数学公式" class="headerlink" title="六、 数学公式"></a>六、 数学公式</h2><h3 id="1-公式声明"><a href="#1-公式声明" class="headerlink" title="1. 公式声明"></a>1. 公式声明</h3><pre><code>行中公式：与其他文字混编
$$ 公式 $$
独立公式： 单独起一行
$ 公式 $</code></pre><h3 id="2-公式元素"><a href="#2-公式元素" class="headerlink" title="2. 公式元素"></a>2. 公式元素</h3><h4 id="希腊字母："><a href="#希腊字母：" class="headerlink" title="希腊字母："></a>希腊字母：</h4><p>常见的\alpah,\beta,\gamma,\omega,\epsilon,\eta,\lambda,\delta,\xi<br>大写的希腊字母，就大写首字母\Alpha</p>
<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><p>太多了，就记下来\times为X乘号，\div为除号</p>
<p>单横线箭头\uparrow，双横线箭头大写首字母U</p>
<ul>
<li>up, down, left, right为四个方向</li>
<li>双向箭头为\leftrightarrow</li>
<li>加长箭头在前面加long. \longuparrow</li>
</ul>
<h3 id="3-公式语法"><a href="#3-公式语法" class="headerlink" title="3. 公式语法"></a>3. 公式语法</h3><ol>
<li><p>上标使用 ^</p>
</li>
<li><p>下标使用 _</p>
</li>
<li><p>积分使用 \int_积分下限^积分上限 {被积表达式}</p>
</li>
<li><p>累加使用 \sum_{下标表达式}^{上标表达式} {累加表达式}<br>累乘\prod 并集\bigcup 交集\bigcap</p>
</li>
<li><p>分数使用 \frac {分子} {分母} 或者 分子 \over 分母</p>
</li>
<li><p>开方使用 \sqrt [开方根，默认为2] {被开方数字}</p>
</li>
<li><p>极限使用 \lim_{变量 \to 表达式} {表达式}</p>
</li>
<li><p>矢量使用 \vec{矢量}</p>
</li>
<li><p><strong>作为一个整体，要用大括号{}</strong></p>
</li>
<li><p>如果要输出大括号，需要加上右斜杠\{ \}</p>
</li>
<li><p>省略号使用 \underbrace{\ldots}_{\rm 被省略的表示}<br>underbrace为下大括号，overbrace为下大括号<br>ldots对齐文本底线，cdots对齐文本中线</p>
</li>
<li><p>注释使用 \text {注释}</p>
</li>
<li><p>字符空格 \,</p>
</li>
</ol>
<h2 id="七、-小结"><a href="#七、-小结" class="headerlink" title="七、 小结"></a>七、 小结</h2><p>总的来说，使用Markdown语法确实比较简单，而且看起来更为美观。它兼容HTML格式，且由于它是纯文本，跨平台性也更好。</p>
<p>段落前后要求有空行（无文字内容）</p>
<p>看起来大方简洁，直观舒服。设置字体颜色还是用font（虽然我老感觉这是HTML语法）</p>
<p><font size=2 color="00AAAA">但是我还是不喜欢用，噜啦啦啦啦啦(//∇//)！因为它显得太松散了，其中一部分功能可能会用，但更多可能还是喜欢直接用html</font></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo使用</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo撰文1</title>
    <url>/2020/02/24/1/</url>
    <content><![CDATA[<p>此文效果全部用Html</p>
<p style = "background: PowderBlue;text-align: center;">博客撰文</p>

<p style = "font-size: 25px">
（猜测：对于md文件中的每一行文字，文章解析时会以回车符分隔，一个回车符代表看做一串文字结束，用一个&lt;p&gt;来存储，放进html中。如果添加了html标签，对于回车符，好像就不能判断了，所有文字将展示为一行，只能自己手动用&lt;br&gt;进行空行）<br>
其实是md语法对html内容不生效，只要遵循md的段落规则就可以实现md兼容html（段落之间用空行分隔），不用手动br<br>
此处，主要思想：在md里添加html标签，标签内嵌css</p>
<a id="more"></a>
<font size=4 color="red">大小、颜色与样式：</font>
用"&lt;font size=4 color="red"&gt;&lt;/font&gt;"（效果为“大小、颜色与样式”）<br>
可以设置字体的大小（默认为3，可为小数）；颜色（可以使用取色板颜色“#FFFFFF”或者“red”“blue”等）；样式（属性名为face）<br>
<font size=4 color="red">背景、居中与样式等：</font>
如果想修改更多属性，比如字体款式、背景颜色。建议自己定义一个&lt;p&gt;或者&lt;span&gt;&lt;li&gt;等标签（他们结束后，会自动产生一个回车符。后面加的一行文字就到下一行啦）<br>
使用<a href="https://www.w3school.com.cn/html/html_styles.asp" target="_blank" rel="noopener">style</a>属性来修改（font比较方便，但是功能有限，style属性淘汰了旧的font属性）<br>
&lt;p style = "background: PowderBlue;text-align: center;"&gt;（效果为“博客撰文”）<br>
<font size=4 color="red">特殊字符：</font>如果想打这五个符号&quot; &apos; &amp; &lt; &gt;请记住，一定要用<a href="https://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">符号实体</a>。<br>
常用六个：
<li>&amp;quot;表示&quot;（双引号）</li>  
<li>&amp;apos;表示&apos;（单引号）</li> 
<li>&amp;amp;表示&amp; </li> 
<li>&amp;lt;表示&lt;（小于号）</li>  
<li>&amp;gt表示&gt;（大于号）</li> 
<li>&amp;nbsp;表示空格（连续的空格符号会被解析为一个，所以要连续空格需要用实体名）</li> 
<br>
<font size=4 color="blue">注意font和style的区别：</font>
<li>font里的属性为size，color，对应的值用=</li>
<li>sytle是属性的集合，要用style=""。属性名与属性值的对应用冒号: 属性间用分号分隔; 。font-size要使用px（像素）作为单位</li>
<p style = "background: PowderBlue;text-align: center;">结束啦</p><br>

<p style = "background: #00AAAA;text-align: center;">引用</p>
最为常见的引用也就是链接网址和插入图片了，链接网址比较容易，直接用&lt;a href=""&gt;就可以了。这里主要讲插入图片<br>
插入图片直接用&lt;img src=""&gt;当然是没有问题的，但是要注意：<font size=3 color="red">插入的图片路径怎么写？</font><br>
我在source文件夹下建立了一个名为img的文件夹专门存放图片<br>
<li>主界面显示：由于文章的当前根目录为source文件夹，要读取下面的文件，直接src="img/1.png"就可以了</li>
<li> 注意！如果图片路径直接写上面的那个，打开文章就会发现，图片无法显示“Not found in ***/***/”这时候就要关注_config.yml中的一个设置permalink:</li>
<li>所谓的permalink，也就是文章的永久地址（设置格式参考Hexo说明），我的设置为 :category/:year/:id/ （分类，年，ID）。分为三层（层数很重要）</li>
<li>文章界面显示：<font size=2.5 color="red">在文章界面，此时的根目录不再是source了</font>，而是文章的permalink。所以，要链接到图片，就先要返回到source目录，由于我设置的是三层，所以应该../三次（返回上层目录）才能回到根目录</li>
<li><font size=3 color="red">于是，最终的src="../../../img/1.png"（../的个数和permalink层数有关，img下创建文件夹也是可以的）</font></li>]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo使用</tag>
      </tags>
  </entry>
  <entry>
    <title>图的连通</title>
    <url>/2020/02/24/A1013/</url>
    <content><![CDATA[<p><font size=4 color="red">没画示意图，美图镇楼</font><br>有向图、无向图与连通性、连通分量、连通图</p>
<a id="more"></a>

<p style = "background: PowderBlue;text-align: center;">无向图</p>

<p><font size=4>1.连通性</font><br>两个顶点vi与vj之间可以互相到达（直接连通或者其他点作为中间点连通），即称为这两个点连通<br><font size=4>2.连通图</font><br>如果一个图里面的任意两个顶点vi和vj都可以互相到达，即称这个无向图为连通图<br><font size=4>3.连通分量</font><br>无向图G的极大连通子图称为G的连通分量。</p>
<ul>
<li>连通图只有一个连通分量，就是它本身</li>
<li>非连通图有多个连通分量</li>
<li><strong>一个有n个连通分量的无向图只用添加n-1个边就能成为连通图</strong></li>
</ul>
<p style = "background: PowderBlue;text-align: center;">结束啦</p>

<p style = "background: #00AAAA;text-align: center;">有向图</p>

<ul>
<li>与无向图定义相同，“强”针对于有向图</li>
<li><strong>n强连通分量的DiG成为强连通图最少添加边不一定是2n</strong></li>
</ul>
<p style = "background: #00AAAA;text-align: center;">结束啦</p>

<img src="../../../img/PAT/1.png">]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>博客雏形</title>
    <url>/2020/02/23/1/</url>
    <content><![CDATA[<p>太不容易了TAT<br>花了一整天时间，终于搭建好了一个博客雏形，node.js + git + hexo结构，用github + gitee代理并国内外分流<br>主题采用大佬写的ayer（简单点来说，大佬做好了一切，我抄了这么久…..）</p>
<a id="more"></a>
<p style = "background: PowderBlue;text-align: center;">遇到了几个坑：</p>
1、nodejs:<br>
    由于node.js是以前配置的，可能没有配置好。导致在hexo下载后，init一直失败，报错async remove(item)<br>网上说现在国内的hexo源有问题，但是我换了好几个源还是没有解决问题。最后才想到是不是node.js配置有问题或者是版本太低，于是就去官网下载了最新版的Nodejs
    （注意！Windows版本不能使用命令升级nodejs，只能去官网下载最新版本，然后同目录覆盖安装）<br>
    下载完之后就成功hexo init了<br>
2、hexo不解释三连：<br>
    在init成功后，我去换了ayer主题，然后开开心心地去看自己的网页~~~发现......<br>
    不仅主题没换，甚至我的title，author什么的都没换！！！<br>
    心态爆炸！！！<br>
    然后处理了好久才知道...我看的是github上代理的网站，我的修改在本地，还没上传.....<br>
    于是深深记住了不解释连招：hexo clean（清除缓存) hexo g（generate，也就是继承） hexo d（deploy 部署）<br>
    再去github的代理商看，好了，我真机智<br>
3、本地修改：<br>
    机智个锤子哦！<br>
    为什么要每次都部署到网站再去看成效？？？直接在本地看，它不香吗？<br>
    于是，再开一个git bash，把hexo server挂着<br>
    用另一个git bash进行其他操作，打开localhost:4000，之后的修改刷新就能看见了<br>
4、分流:<br>
    虽然github代理这一步完成得还是比较顺利，但是测试起来，这网速....确实不敢恭维<br>
    （导致还去用vps配了个ss翻墙，网速同样不敢恭维，延迟一般在100-200ms，但是进网站加载速度太慢，看油管都费劲。不过还好，我主要用来下东西，它下载速度还挺令我开心，现在下的都是1s内完成，预测速度40+m/s）<br>
    然后看教程，推荐分流代理，国内有coding，gitee用得比较多。coding跳转有广告，交钱或者给他打宣传就可以省去广告<br>
    于是国内选择了gitee<br>
5、gitee：<br>
    使用了gitee后，又被坑了....<br>
    第一个：秘钥...原来，秘钥还有公用和私用啊...添加的秘钥在gitee里，默认是公用（只能看），但是右上角有提示去添加私用的（能读能写）<br>
    第二个：说好的仓库名随便的！结果仓库名和Pages服务有关，如果和用户名不一样，又要配置什么root之类的。<br>
    开始傻乎乎的把Pages服务的url复制上去了，然后只有index传上去了，外联的图片、css和js什么都没，又傻了。<br>
    结果将仓库名和存储地址改为用户名，relo地方写仓库的pull的SSH就好了<br>
    <font color=red size=3>注意：每次的gitee部署完之后，要去gitee的Pages里面手动更新一下</font><br>
<p style = "background: PowderBlue;text-align: center;">上一部分结束啦</p>
现在博客字体什么的又不太熟悉了，还得去看看css和html教程咯]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>纪念</tag>
      </tags>
  </entry>
</search>
