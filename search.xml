<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>h5格式</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020/ckawn5m080005qkk6c1b03qeg/</url>
    <content><![CDATA[<p><font color = 'red'>打印数据存在问题</font></p>
<h1 id="h5简介"><a href="#h5简介" class="headerlink" title="h5简介"></a>h5简介</h1><p>背景：CV、DL等涉及神经网络的各模型，卷积层和全连接层往往有很多神经元，训练完模型后，大量的weights的存储，可以使用h5格式存储</p>
<p>HDF（Hierarchical Data Format）<strong>层次数据格式</strong>指一种为存储和处理大容量科学数据设计的文件格式及相应库文件</p>
<a id="more"></a>
<h2 id="h5读取"><a href="#h5读取" class="headerlink" title="h5读取"></a>h5读取</h2><h3 id="神经网络读取"><a href="#神经网络读取" class="headerlink" title="神经网络读取"></a>神经网络读取</h3><p>此处顺便记录一下tf2用class定义网络</p>
<pre><code>import tensorflow as tf
from tensorflow.keras.models import Model
###方式1：使用Class###
Class model(Model):
    def __init__(self):
        super(model, self).__init__
        self.cbapd()=..... #八股定义CBAPD
    def call(self)
        x = self.cbapd(x)
        y = self.cbapd(x)

###方式2：函数返回Class###
def model(train, validate):
    x = cbapd(train)
    y = cbapd(x)
    return Model(x, y, name = &apos;model&apos;)

if __name__ == &apos;__main__&apos;:
model = model()
model.load_weights(&apos;weights.h5&apos;)</code></pre><h3 id="打印内容"><a href="#打印内容" class="headerlink" title="打印内容"></a>打印内容</h3><p>使用h5py库类似excel的读取（类似一个map,拥有多个key，每个key对应value)</p>
<pre><code>import h5py
import numpy as np
f = h5py.File(&apos;weights.h5&apos;, &apos;r&apos;) #用只读方式 打开h5文件
print(f.keys()) #打印所有的key
for key in f.keys():
    data = np.array(f[key])
    print(data)</code></pre><p><font color="red">不明原因报错</font><br>根据报错信息，应该是data里面有数据的类型不支持译码为ascii（可能是个例）</p>
<pre><code>运行时候  File &quot;D:\programming\python\lib\site-packages\h5py\_hl\base.py&quot;, line 137, in _e
name = name.encode(&apos;ascii&apos;)
AttributeError: &apos;slice&apos; object has no attribute &apos;encode&apos;</code></pre>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>h5</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorFlow2.0</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020/2/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>通过清理废弃的API和减少重复来简化API</li>
<li>运行后就得出结果（1是用建立图模型后用session运行）</li>
<li>使用Keras和eager execution轻松构建模型</li>
<li>标准化交换格式改进平台和跨语言部署</li>
</ul>
<h3 id="tf-keras"><a href="#tf-keras" class="headerlink" title="tf.keras"></a>tf.keras</h3><p>构建和训练模型的核心高级API（官方指定）</p>
<h3 id="Eager模式和自定义训练"><a href="#Eager模式和自定义训练" class="headerlink" title="Eager模式和自定义训练"></a>Eager模式和自定义训练</h3>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Tensorflow2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>目标检测</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/2020/1/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="目标检测"><a href="#目标检测" class="headerlink" title="目标检测"></a>目标检测</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>目标检测是在图片中对<font color="red">可变数量</font>的目标进行查找和分类</p>
<p>主要问题：</p>
<ul>
<li>目标种类和数量</li>
<li>环境的干扰</li>
<li>目标框的大小</li>
</ul>
<h3 id="目标检测-图像分类-目标分割"><a href="#目标检测-图像分类-目标分割" class="headerlink" title="目标检测-图像分类-目标分割"></a>目标检测-图像分类-目标分割</h3><ul>
<li>目标检测：检测物体位置，用矩形框标注，并标明其概率</li>
<li>图像分类：识别出一个图片包含哪些物体，并给其标注tags，再根据tag分类</li>
<li>目标分割：寻找物体具体位置。像素级别识别图像中的物体（类似红外线扫描仪效果….）<ul>
<li>语义分割：对于每一个像素点判断其属于哪一个分类</li>
<li>实例分割：在语义分割的基础上，对同一分类的目标也要标明不同</li>
</ul>
</li>
</ul>
<h3 id="历史演变"><a href="#历史演变" class="headerlink" title="历史演变"></a>历史演变</h3><table>
<thead>
<tr>
<th align="left">年份</th>
<th align="left">检测方式</th>
<th align="left">分类特征值获取</th>
<th align="left">代表技术</th>
<th align="left">改进</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2001-2012</td>
<td align="left">滑动窗口</td>
<td align="left">手工设置</td>
<td align="left">VJ，DPM</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">2012-2015</td>
<td align="left">滑动窗口</td>
<td align="left">卷积神经网络提取</td>
<td align="left">Overfeat，RCNN</td>
<td align="left">特征值自动提取且有更好适应性</td>
</tr>
<tr>
<td align="left">2015-(Two-stage)</td>
<td align="left">Proposal</td>
<td align="left">卷积神经网络提取</td>
<td align="left">Fast RCNN，Faster RCNN</td>
<td align="left">提高搜索框提取目标区域的速度</td>
</tr>
<tr>
<td align="left">2015-(One-stage)</td>
<td align="left">目标框回归</td>
<td align="left">自动提取</td>
<td align="left">YOLO，SSD</td>
<td align="left">速度提升，精度稍降</td>
</tr>
</tbody></table>
<p>传统算法（2012之前）：输入——<font color="blue">候选框——特征提取——分类——</font>NMS——输出<br>深度学习（2012之后）：输入——<font color="blue">特征提取——回归——</font>NMS——输出</p>
<p>传统算法特征值提取一般关注纹理</p>
<ul>
<li>VJ的Harr特征：颜色只有黑白，采取多形状多方向得到特征值</li>
<li>HOG特征：图片灰度化后Gamma变化，计算每一个点的梯度map（xy方向量化），点组成cell得到梯度直方图，相邻多个cell组成block进行特征归一化，多个block串联并归一化</li>
<li>DPM（物体检测，HOG拓展）：梯度分为有符号和无符号，用加法代替乘法</li>
</ul>
<p>NMS（非极大值抑制算法）：同一个物体的识别，只保留识别分数最高的识别框</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>目标检测</tag>
      </tags>
  </entry>
  <entry>
    <title>python的numpy库</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020/2/</url>
    <content><![CDATA[<p>现在很多做神经网络模拟或者其他计算量比较大的实验时，都会选择使用python语言，我认为numpy库功不可没</p>
<p>此处记录numpy库的一些基本内容和常用函数</p>
<a id="more"></a>

<h1 id="numpy库"><a href="#numpy库" class="headerlink" title="numpy库"></a>numpy库</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>NumPy(Numerical Python) 是Python 语言的一个扩展程序库，支持高维度数组与矩阵运算，并提供大量的数学函数库。</p>
<pre><code>安装还是使用pip install numpy，网速不行就使用镜像网址
引用import numpy as np，以下简称np</code></pre><h2 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h2><h3 id="声明和赋值"><a href="#声明和赋值" class="headerlink" title="声明和赋值"></a>声明和赋值</h3><pre><code>NumPy库的array函数：numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></pre><p>一般只用关心object(数组或者嵌套数组)，剩下的可选内容中常用的是dtype（数组元素的数值类型）</p>
<pre><code>一维数组：a = np.array([1, 2, 3])
二维数组：a = np.array([[1, 2], [3]], dtype = &apos;float&apos;)</code></pre><p>嵌套数组一般为二维数组，可以使用a[0][0]访问</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>python</tag>
        <tag>numpy库</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网路向前与向后推导</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/2020/1/</url>
    <content><![CDATA[<p>人工智能和深度学习已经成为了当前很火的名词，在深度学习算法中，第一个接触的便是神经网络算法</p>
<p>对于一个神经网络，定义分为：输入层，隐含层，输出层 共三部分</p>
<ul>
<li>输入层：输入的数值inputs</li>
<li>隐含层：可能会有多个隐含层，只有一个隐含层则称此神经网络为“双层神经网络”，两个隐含层则称为“三层神经网络”…..</li>
<li>输出层：最终的输出outs</li>
</ul>
<a id="more"></a>

<p>对于一个神经网络，为了让其能达到我们目标要求，所以我们要先“训练”它:</p>
<ul>
<li>首先即给定输入inputs和正确的输出targer_out</li>
<li><font color="red">正向推导</font>：从输入层inputs附加权重计算得到隐含层h，再从隐含层h附加权重计算得到输出层o</li>
<li>根据得到的输出层o和预期输出target_out计算出神经网络的总误差Loss_total(以下记为E_total)</li>
<li><font color="red">反向推导</font>：根据总误差，从输出层开始调整其到第一个隐含层的权重，再逐步调整，最后调整隐含层到输入层的系数</li>
<li>经过不断循环正向推导和逆向推导，最终总误差达到一个可以接受的范围，及训练完成</li>
</ul>
<p><font color="red">训练的过程是一个递归的过程</font>，一步步调整参数大小。打有可能出现调整很多次(step很大)时候还没有达到预期，这时候要考虑调整隐含层层数和因素多少。</p>
<p>本次使用的是python做神经网络的模拟推导（没研究markdown的数学符号，就在草稿纸上写的），使用了numpy库（具体内容会在另一篇博客中）</p>
<p style = "background: PowderBlue;text-align: center;">以下为推导过程</p>

<img src="../../../img/DeepLearning/1.png">
<img src="../../../img/DeepLearning/2.png">
<img src="../../../img/DeepLearning/3.png">
<img src="../../../img/DeepLearning/4.png">

<p>图中推导为草稿部分，所以写得不太工整和详细</p>
<p style = "background: PowderBlue;text-align: center;">推导过程结束</p>


<p><font color="red">有以下几点需要注意，对于逆向推导十分重要</p>
<ol>
<li><p>对于隐含层和输出层，我们要区分其得到的结果分为两部分net和out</p>
<ul>
<li>net为网络计算出的结果,out为激活后的结果</li>
<li>同一层的一个值的out值到net值的求导，即为对sigmoid函数求导，得到dao_sigmoid(x) = sigmoid(x) * (1-sigmod(x))</li>
<li>由于正向推导用的值都是激活后的值，所以逆向推导只能由当前层的net值求导上一层out值</li>
</ul>
</li>
<li><p>掌握好链式推导法则</p>
<ul>
<li>梯度变换曲率都是E_total对权重w的求导，但是展开式却有所不同，要观察权重影响的值</li>
<li>图中的w5-w8只影响o的值。比如w5只影响o1的值，那么链式求导E_total——&gt;out_o1——&gt;net_o1——&gt;w5</li>
<li>图中的w1-w4既影响h的值，也影响o的值。比如w1影响h1的值，但同时h1又影响o1和o2的值，所以此处要把E_total分为E_o1和E_o2<br>推导：E_total——&gt;E_o1, E_o2——&gt;out_o1, out_o2——&gt;net_o1, net_o2——&gt;out_h1——&gt;net_h1——&gt;w1</font>

</li>
</ul>
</li>
</ol>
<p>代码：</p>
<pre><code>import numpy as np

def sigmoid(x):
    y = 1.0 / (1.0 + np.exp(-x))
    return y

def dao_sigmoid(x):
    y = sigmoid(x) * (1 - sigmoid(x))
    return y

if __name__ == &apos;__main__&apos;:

    #参数预设:inputs为输入，weights1为输入层到隐含层，weights2为隐含层到输出层，b为偏向，target_o为预期输出，learning_rate为学习系数
    inputs = np.array([0.05, 0.10], dtype = &apos;float&apos;)
    weights1 = np.array([[0.55, 0.75], [0.95, 0.15]], dtype = &apos;float&apos;)
    weights2 = np.array([[0.75, 0.15], [0.80, 0.60]], dtype = &apos;float&apos;)
    b = np.array([0.15, 0.80], dtype = &apos;float&apos;)
    target_o = np.array([0.01, 0.99], dtype = &apos;float&apos;)
    learning_rate = 0.5

    #设置正向推导两次。步数step从0开始
    target_step = 2
    step = 0

    while step &lt; target_step:
        print(&quot;Step :%d&quot;%(step))
        #计算隐含层h1和h2
        net_h = np.dot(inputs, weights1) + b[0]
        out_h = sigmoid(net_h)
        #计算输出层o1和o2
        net_o = np.dot(out_h, weights2) + b[1]
        out_o = sigmoid(net_o)
        #计算损失函数
        loss_total = np.sum((target_o-out_o)**2)/target_o.size
        #梯度变换曲率
        weight5, weight6 = -(target_o[0]-out_o[0]) * dao_sigmoid(net_o[0]) * out_h
        weight7, weight8 = -(target_o[1]-out_o[1]) * dao_sigmoid(net_o[1]) * out_h
        weight1, weight2 = (-(target_o[0]-out_o[0])*dao_sigmoid(net_o[0])*weights2[0][0] -(target_o[1]-out_o[1])*dao_sigmoid(net_o[1])*weights2[0][1]) * dao_sigmoid(net_h[0]) * inputs
        weight3, weight4 = (-(target_o[0]-out_o[0])*dao_sigmoid(net_o[0])*weights2[1][0] -(target_o[1]-out_o[1])*dao_sigmoid(net_o[1])*weights2[1][1]) * dao_sigmoid(net_h[1]) * inputs
        #更新参数
        weights1[0][0] = weights1[0][0] - learning_rate*weight1
        weights1[1][0] = weights1[1][0] - learning_rate*weight2
        weights1[0][1] = weights1[0][1] - learning_rate*weight3
        weights1[1][1] = weights1[1][1] - learning_rate*weight4
        weights2[0][0] = weights2[0][0] - learning_rate*weight5
        weights2[1][0] = weights2[1][0] - learning_rate*weight6
        weights2[0][1] = weights2[0][1] - learning_rate*weight7
        weights2[1][1] = weights2[1][1] - learning_rate*weight8
        #输出（就不写明了，看代码应该能明白）
        print(out_h)
        print(out_o)
        print(loss_total)
        print(weights1)
        print(weights2)
        print(&quot;\n&quot;)
        step = step+1</code></pre>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>饥荒服务器搭建</title>
    <url>/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/2020/1/</url>
    <content><![CDATA[<p>由于新型冠状病毒的原因，已经宅家两个多月了。缺乏自制力，所以一直在打游戏。</p>
<p>加了很多房间，但是其中大部分都会莫名其妙的卡，在观看一些自己搭建服务器的视频之后，我也跟着教程走，自己搭一个服务器试一下。</p>
<a id="more"></a>

<h2 id="Ubuntu和CentOS"><a href="#Ubuntu和CentOS" class="headerlink" title="Ubuntu和CentOS"></a>Ubuntu和CentOS</h2><p>这是我第一次使用Linux系统，首先便是了解Ubuntu和CentOS两个分支的关系和区别（不全面，只是了解的部分）</p>
<ul>
<li><p><font size="5" color="red">来源</font></p>
<ul>
<li>CentOS是Linux发行版本之一，源自Red HAT Enterprise开放源码编译而成，所以它支持rpm格式安装</li>
<li>Ubuntu基于Debian发行版和Gnome桌面环境，是一个以桌面应用为主的Linux操作系统。它不支持rpm格式安装</li>
</ul>
</li>
<li><p><font size="5" color="red">用途</font></p>
<ul>
<li>CentOS具有高度稳定性，可以代替Red HAT Enterprise作为服务器</li>
<li>Ubuntu提供用户一个开放版的社区，稳定且更新快，是由自由软件构成的操作系统</li>
</ul>
</li>
<li><p><font size="5" color="red">系统用户</font></p>
<ul>
<li>CentOS的新建用户没有管理员权限。如果需要添加管理员权限，需要到/etc/sudoers中加入用户和权限。使用”su root账户的密码”即可切换到管理员账户</li>
<li>Ubuntu的用户要使用管理员权限”sudo 命令”，第一次使用需要输入当前用户的密码。可直接使用管理员用户登录，步骤如下（都要加sudo）：<ol>
<li>“sudo passwd root”设置管理员密码，运行后会首先输入一次密码，然后确认一次。</li>
<li>“sudo vi /etc/ssh/sshd_config”系统本身是空密码管理员登录，找到其中”PermitRootLogin without-password”（无密码管理员登录）修改为”PermitRootLogin yes”（打开管理员密码登录)</li>
<li>“sudo services ssh restart”重启ssh服务，即可使用root用户登录，密码为第一步中设置的密码</li>
</ol>
</li>
</ul>
</li>
<li><p><font size="5" color="red">在线安装</font></p>
<ul>
<li>CentOS使用yum命令（后面加目标地址）</li>
<li>Ubuntu使用apt-get命令（后面加目标地址)</li>
</ul>
</li>
</ul>
<h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><p>Linux系统中，命令没有大写</p>
<h3 id="输出命令echo和printf"><a href="#输出命令echo和printf" class="headerlink" title="输出命令echo和printf"></a>输出命令echo和printf</h3><ul>
<li><p>echo:</p>
<ul>
<li>“echo $value”输出变量value的值。比较常用简单输出</li>
<li>“echo -e”格式化输出后面的内容。格式化包括\t(横向制表符)，\n(换行)，\e(修改颜色,\e[0m为结束标识)等。<br>比如 echo -e “\e[31m hello world \e[0m”</li>
</ul>
</li>
<li><p>printf:</p>
<ul>
<li>使用规则和c语言差不多，但是功能没有那么强大了，主要用于awk命令，适合比较复杂的输出</li>
<li>printf自带格式化输出功能。比如\t(横向制表符)，\v（垂直制表符)，\n(换行)，%s(字符串内容)，%d(十进制整数)，%f(浮点数)<br>比如 printf “%s\t %s\t %s\t\n” [1]姓名:$name [2]性别:$sex [3]年龄:$age</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>云服务器</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>云服务器</tag>
        <tag>Linux系统命令</tag>
      </tags>
  </entry>
  <entry>
    <title>软件文档第一次实验</title>
    <url>/%E8%BD%AF%E4%BB%B6%E6%96%87%E6%A1%A3/2020/1/</url>
    <content><![CDATA[<h1 id="软件文档之我见"><a href="#软件文档之我见" class="headerlink" title="软件文档之我见"></a>软件文档之我见</h1><a id="more"></a>

<h2 id="软件文档"><a href="#软件文档" class="headerlink" title="软件文档"></a>软件文档</h2><p>软件文档，从字面上来讲，即为“描述软件的相关文档”。</p>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><h4 id="软件的构成"><a href="#软件的构成" class="headerlink" title="软件的构成"></a>软件的构成</h4><p>在计算机应用的早期，软件是不包括文档的，软件仅包括“程序”和“框图”两部分。简单的软件用框图即可说明，但随着计算机行业的高速发展，软件的规模也在不断扩大，结构简单的框图已经无法满足需求了。进入软件工程化阶段后，“文档”的作用和地位不断上升，取代了“框图”。到现在，软件在各行业得到普遍应用，“数据”自然也就成为了软件关键的一部分。于是便形成了现在的<strong>软件=程序+文档+数据</strong>结构。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>文档即每种数据媒体和其中所记录的数据。</p>
<ul>
<li>文档具有永久性，可供人或机器阅读（通常指专供人阅读的东西）。</li>
<li>文档作为计算机软件的重要组成部分，它告诉用户如何操作和维护系统，提供关于未来改进和重新实施所需的信息，在开发人员、维护人员、管理人员、用户与计算机之间起着桥梁作用</li>
</ul>
<h4 id="文档的作用"><a href="#文档的作用" class="headerlink" title="文档的作用"></a>文档的作用</h4><ul>
<li>管理的依据</li>
<li>技术交流的语言</li>
<li>软件质量的保证</li>
<li>支持培训与参考</li>
<li>支持软件维护</li>
<li>记录软件的历史</li>
</ul>
<h4 id="文档的分类"><a href="#文档的分类" class="headerlink" title="文档的分类"></a>文档的分类</h4><ul>
<li>按照生产和使用的范围<ul>
<li>管理类文档：记录项目管理的信息</li>
<li>开发类文档：描述软件开发过程本身</li>
<li>产品类文档：描述开发过程的产物（软件自身）</li>
</ul>
</li>
<li>按阅读对象<ul>
<li>管理人员</li>
<li>开发人员</li>
<li>维护人员</li>
<li>最终用户</li>
</ul>
</li>
<li>按软件开发方法<ul>
<li>面向过程的文档</li>
<li>面向对象的文档</li>
</ul>
</li>
</ul>
<h4 id="文档标准"><a href="#文档标准" class="headerlink" title="文档标准"></a>文档标准</h4><p>软件的规模和复杂度在持续的增加，人们对软件产品开发过程系统化、规范化和标准化的要求也越来越严格，因此，软件工程标准化、软件文档规范化，已经成为软件领域影响软件行业发展的一个重要因素，并制定了如下的标准层次。</p>
<p>标准层次</p>
<ul>
<li>国际标准：由国际联合机构制定和公布的标准，供各国参考<ul>
<li>ISO—国际标准化组织</li>
</ul>
</li>
<li>国家标准：由政府或国家级的机构制定或批准，适用全国范围<ul>
<li>GB—中国国家标准</li>
<li>ANSI—美国国家标准</li>
<li>BS—英国国家标准</li>
<li>GJB—中国国家军用标准</li>
</ul>
</li>
<li>行业标准：由行业机构、学术团体或国防等机构制定，适用某业务领域<ul>
<li>IEEE—美国电气和电子工程师协会</li>
</ul>
</li>
<li>企业规范：企业因软件工作的需要制定的适用本企业的规范<ul>
<li>IBM通用产品部于1984年制定的《程序设计开发指南》</li>
</ul>
</li>
<li>项目规范：由某科研生产组织制定，仅为该组织服务的软件工程规范</li>
</ul>
<h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><h3 id="软件文档与软件生命周期"><a href="#软件文档与软件生命周期" class="headerlink" title="软件文档与软件生命周期"></a>软件文档与软件生命周期</h3><p>软件生存周期：从构思软件产品开始到该产品不能再使用时为止的时间段。<br>通常划分为计划、开发、运行三个时期，不同时期不同角色参与其中。而软件文档伴随不同的角色，贯穿软件生存周期始终。</p>
<ul>
<li><p><strong>计划时期</strong>主要任务为问题分析、可行性研究何制定计划。在这一阶段，软件文档的撰写应该主要由产品经理、市场调研人员等人完成，文档的目的是分析问题，根据市场调研以及其他相关资料，来分析可能出现的问题，包括其能否被解决、大约需要多长时间、方案是否可行等问题。<strong>相当于对软件进行了一次模拟开发与总结</strong>，已经预测了大部分可能遇见的问题，这样大大降低了开发中途遇到无法解决的问题而导致前功尽弃的概率，降低了双方不必要的损失：开发方花废时间、人力开发软件，但是得到的只是半成品，无实际意义；需求方花费时间说明和等待，最后却得不到理想中的产品。</p>
</li>
<li><p><strong>开发时期</strong>主要任务为需求分析，概要设计，详细设计，编码测试，软件发布。在这一阶段，软件文档的撰写应该由开发团队完成，并提供给开发团队中各个功能模块的设计开发人员，为其详细设计提供指导依据。</p>
<ul>
<li><p>需求分析：首先要根据用户的需求做一个详细的分析：有哪些方面的需求、需求应该完成到什么地步、客户允许多大程度的失误率等。<strong>一个良好的需求需求文档是成功的一半。</strong></p>
</li>
<li><p>概要设计：主要是将任务不断划分为小的任务，不进行实际的编码，只考虑前期的定义和输入输出</p>
<ul>
<li>首先要定义好软件的开发环境：运行平台，硬件环境与软件环境</li>
<li>其次，要将软件系统划分为多个子系统并绘制出系统结构：包括总体结构图、功能结构图、数据库E-R图和整体流程图</li>
<li>针对每一个子系统再次划分模块，每一个模块定义其功能描述、模块输入、模块输出、接口设计四个部分</li>
<li>最后要写明数据库的设计，根据实际需求对一部分模块或者子模块定义其表中的数据中英文名称、字段类型、是否为主键、能否为空</li>
</ul>
</li>
<li><p>详细设计：延续概要设计的子系统和模块划分。针对每一个子系统说明其硬软件要求、主要功能、工作流程、模块的划分，对于其中的模块，要描述清楚其功能描述、输入输出、接口设计、流程图、方法说明和界面设计。<strong>在这一阶段，可执行软件已经生成</strong></p>
</li>
<li><p>编码测试：对于一个可执行软件，还要测试其是否满足用户需求，需要对每一个模块进行测试，包括但不限于计算模块计算节点软件测试、显示模块功能测试、功能测试。记录测试环境、测试项、测试函数、测试用例、测试结果和问题需要的备注。最后针对整体得出软件的能力、缺陷、限制、建议和评价。开发人员再根据测试结果修改代码，直到测试结果满意。<strong>在这一阶段，满足需求且能处理部分异常的软件生成</strong></p>
</li>
<li><p>软件发布：满足需求的软件可以发布了，但是对于它的使用还需要一个文档说明。这一阶段文档最终面向使用者，需要说明软件的使用要求和软件的功能等</p>
</li>
</ul>
</li>
<li><p><strong>运行时期</strong></p>
<ul>
<li>运行维护：随着软件的运行，可能会出现一部分测试时没有出现的问题，需要进行软件的维护；或者随着硬软件条件的改变与需求的改变，软件需要更新。这一阶段，文档需要记录软件出现的问题，对于每次新版本的发布，告知使用者软件已解决的问题。</li>
</ul>
</li>
</ul>
<h3 id="文档的作用-1"><a href="#文档的作用-1" class="headerlink" title="文档的作用"></a>文档的作用</h3><p>软件文档伴随不同的角色，贯穿软件生存周期始终。各个时期的文档撰写的人不同，阅读的人也不同，同时文档专注的内容也是天差地别。但是，每个时期的文档都对软件开发起着指导性作用，它规范了软件开发的流程，实现了与客户的良好交流，将需求细分为小的模块，分组实现，极大程度上节省了人力、物力、财力和沟通的时间。</p>
<p>总结一下之后，软件文档对于软件开发的意义如下</p>
<ul>
<li>提高软件的可靠性、可维护性和可移植性</li>
<li>提高软件的生产率和软件人员的技术水平</li>
<li>提高软件人员之间的通信效率，减少差错和误解</li>
<li>有利于软件管理</li>
<li>有利于降低软件产品的成本和运行维护成本</li>
<li>有利于缩短软件开发周期</li>
</ul>
<h2 id="对文档的态度"><a href="#对文档的态度" class="headerlink" title="对文档的态度"></a>对文档的态度</h2><h3 id="个人经历"><a href="#个人经历" class="headerlink" title="个人经历"></a>个人经历</h3><p>在“软件开发综合能力训练”里面，我担任组长一职，我们团队进行了为期两周的“二手市场交易平台”的开发。从一开始的软件规格说明书，到后来的站立会议、迭代总结等，再到用户使用说明，文档贯彻了我们开发的全部流程。作为项目负责人，我负责了文档撰写工作，也参与了其中的编码等工作，我深深感受到了文档的重要性：<strong>软件文档贯彻着整个软件生命周期，对软件开发起着指导性作用</strong>。</p>
<ul>
<li>最开始的软件规格说明书，已经在很大程度上定义了软件各项功能、硬软件要求等，是对软件一个大体的规划</li>
<li>站立会议让小组成员聚集在一起，报告自己的工作进度和遇到的问题。将问题告知大家，加强了团队的沟通，负责人也可以根据站立会议的结果进行任务分配的调整</li>
<li>迭代报告总结了每一次迭代的目标和完成情况。这使团队开发流程更规范，有阶段性目标，更利于完成大的软件。并且每一次迭代任务进行总结，也给下一次迭代起到警示作用</li>
</ul>
<h3 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h3><p>大致阅读了杨帆老师提供的软件文档之后，对比我之前写的文档和开发经历，我感悟颇深</p>
<ul>
<li>需求文档。需求文档需要做好所有的需求的分析，而我们小组之前的需求文档太模模糊糊了，对需求分析不够透彻，同时也无法对需求做出好的总结和规划</li>
<li>概要设计。概要设计要划分好软件的子系统、模块和它们之间的关系，对于模块要定义其输入输出。我们小组在之前的开发，忽略了软件模块的划分等，没有对模块进行好定义、数据库设计不清晰，导致我们开发过程中出现了很大的分歧，对许多输入和输出有不同的看法，于是我们在解决这些矛盾时候又浪费了大量的时间，也让一些开发人员的功能白做了。</li>
<li>详细设计。详细设计要详细定义模块的功能、流程图、接口等，其实已经对功能基本实现。我们之前撰写的详细设计更像是概要设计，不够清晰详尽。</li>
<li>总得来说，可能是由于没有开发经历，第一次的文档撰写和整个开发过程都显得有些紊乱，每个人对自己的任务不太清楚，团队间的沟通也不够。同时这也体现了软件文档对整个软件生命周期的重要性，它很好地将大任务划分为小任务，将小任务分配给个人，阶段性开发，让开发人员更明确自己的职责，团队里面出现的问题及时沟通及时解决，测试结果也能准确分发给负责开发的人员，让整个流程更加规范、高效</li>
</ul>
<h2 id="小建议"><a href="#小建议" class="headerlink" title="小建议"></a>小建议</h2><p>上了一周的课，杨帆老师本人诙谐幽默，讲课引人入胜，让我们在欢声笑语中就对软件文档有了一个系统性了解：软件定义的发展，文档的产生，文档的作用，软件生命周期和文档的关系，文档的标准。结合老师给的文件和自己的开发经历，有了更深刻的理解。</p>
<p>但是，对于<em>文档的标准</em>这一部分，可能是本身就不太好讲解，也可能是我的理解不够深入、没有去单独阅读文档标准文档，我对这一部分的理解不够透彻。我仅知道文档需要用一个标准来规范化，且这个标准由各种机构来定义，但是不太了解何为达到标准，结合了老师的文档才有了浅薄理解。</p>
<p>建议老师在之后讲解这种定义比较模糊的东西时，辅助以例子讲解，这样我们学生理解起来可能更容易一点。</p>
]]></content>
      <categories>
        <category>软件文档</category>
      </categories>
      <tags>
        <tag>软件文档</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server 2019 安装报错处理</title>
    <url>/SQLServer2019/2020/1/</url>
    <content><![CDATA[<p>商导快开课了，老师让提前下好SQLServer，推荐2017版本，同时承诺：“如果用2019版本完成作业直接给满分！”</p>
<p>看了下安装教程，很简单嘛(^_^) 二话不说，冲上来试试</p>

<p>前面就是设置安装路径和选择安装组件，简简单单，稳稳当当，直到…..我碰见这两兄弟TAT</p>
<a id="more"></a>

<hr>
<h2 id="报错一"><a href="#报错一" class="headerlink" title="报错一"></a>报错一</h2><p><font size="4" color="red">“以前的某个程序安装已在安装计算机上创建挂起的文件操作。安装程序前必须重新启动计算机”</font></p>
<p>重启就重启！</p>
<p>5 minutes later…</p>
<p>没用啊！</p>
<p>然后才知道，要删除注册表 “PendingFileRenameOperations” <font size="2.5" color="00AAAA">（注册表打开方式见文末）</font></p>
<p>路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</p>
<img src="../../../img/MSSQL/1.png">

<p>（图中已经删了，这个注册表应该在箭头处。它不在Session Manager目录的子文件夹内，而是在一个文件，不要在左边找）</p>
<p>然后就美滋滋安装了</p>
<h2 id="报错二"><a href="#报错二" class="headerlink" title="报错二"></a>报错二</h2><p><font size="4" color="red">“tmpBD0A.tmp: Unable to save temp file [操作已超时。]”</font></p>
<h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><p>如果安装R和Python深度学习功能，就会发现：在最后下载几个.cab文件，明明不大，但是却会卡好久…..</p>
<p>“完成但错误”，这有锤子用啊！我又用不了，就像 给我下载一个快捷方式但是不给我文件…</p>
<p>然后根据报错信息，去 C:\Program Files\Microsoft SQL Server\150\Setup Bootstrap\Log 找它的安装记录</p>
<img src="../../../img/MSSQL/2.png">

<p>报错信息总结一下：安装 SRS 和 SPO 获取资源超时（写着像是存储失败，但是同一个文件夹，其他的东西可以存进去，这个文件不能存进去，不大现实）</p>
<ul>
<li>第一个字母S取自MicroSoft的s</li>
<li>第二个字母：R代表R Studio语言，即选择安装的R语言；P代表Python语言</li>
<li>第三个字母：S代表Server，服务器端；O代表Open，也就是客户端需要的环境（安装过程需要同意的）</li>
</ul>
<p>获取资源超时，结合以前的认知，也很正常，毕竟是外网的东西，很可能连接失败什么的</p>
<h3 id="卸载组件，下载组件包"><a href="#卸载组件，下载组件包" class="headerlink" title="卸载组件，下载组件包"></a>卸载组件，下载组件包</h3><p>一般的可以尝试重复下载。但是SQLServer有点坑，“安装完成但错误”将视为组件成功安装，已安装的组件不能再次安装<br><font size="3" color="red">在修复界面修复一定会修复失败!从未成功安装过，无法修复！</font></p>
<p>首先要来<a href="https://docs.microsoft.com/en-us/sql/advanced-analytics/install/sql-ml-component-install-without-internet-access?view=sql-server-ver15" target="_blank" rel="noopener">下载机器学习的R语言和Python包</a>，将下载的.cab文件放在一个文件夹下</p>
<p>然后要在“添加与删除”（win10叫“应用与程序”）选择卸载Microsoft SQL Server 2019</p>
<p>在卸载界面卸载R与Python组件</p>
<img src="../../../img/MSSQL/3.png">

<p>成功卸载</p>
<img src="../../../img/MSSQL/4.png">

<h3 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h3><p>按照下载界面提示重新进入安装界面，<font size="4" color="red">断网！</font></p>
<p>按照引导会让我们选择目标文件夹，选择下载的.cab文件所在的文件夹即可</p>
<p>由于我是中文版，语言应为2052（简体中文），而下载的包语言为1033（英文），故需要<font size="3" color="red">把包的每一个名字最后的1033改为2052</font>，不然无法识别</p>
<p>然后点击下一步，等待软件安装完毕即可</p>
<img src="../../../img/MSSQL/5.png">

<p>美滋滋，安装成功！<br><img src="../../../img/MSSQL/6.png"></p>
<h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p style = "background: PowderBlue;text-align: center;">注册表管理</p>

<ul>
<li>Win + R快捷键打开“运行”界面</li>
<li>输入“regedit”并回车</li>
<li>已经到了“注册表管理”界面啦</li>
</ul>
<p style = "background: PowderBlue;text-align: center;">结束啦</p>]]></content>
      <categories>
        <category>SQLServer2019</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL Server 2019</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo撰文2</title>
    <url>/Hexo%E5%8D%9A%E5%AE%A2/2020/2/</url>
    <content><![CDATA[<p>上文是讲的通过html直接修改文字效果，其实我们可以直接用markdown语法做其中部分处理，写起来会更为简洁<br>此文效果全部用Markdown语法，只写些常用的（就是懒！），效果图主要看字面意思+想象力（不想写太长๑Ő௰Ő๑）</p>
<a id="more"></a>
<h1 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h1><p>Markdown是一种纯文本格式的标记语言（类似XML哦），利用一些简单语法就可以实现文章的排版变化，让使用者可以把更多注意力放在内容上</p>
<h2 id="一、-标题和目录"><a href="#一、-标题和目录" class="headerlink" title="一、 标题和目录"></a>一、 标题和目录</h2><p>#后<strong>加空格</strong>再加文字内容，就可以实现标题，一个警号代表一级标题，最多支持六级标题。</p>
<p>当然，没有规定预定要从一级标题开始设置，标题级别主要影响字体大小，可以按需来<br>之后，Markdown会根据标题生成目录，目录就可以精确定位到某个标题</p>
<h2 id="二、-字体设置"><a href="#二、-字体设置" class="headerlink" title="二、 字体设置"></a>二、 字体设置</h2><h3 id="1-斜体"><a href="#1-斜体" class="headerlink" title="1. 斜体"></a>1. 斜体</h3><pre><code>*要设置为斜体的内容*（不要空格,星号可以用下划线_代替）</code></pre><p><em>要设置为斜体的内容</em>（不要空格,星号可以用下划线_代替）</p>
<h3 id="2-加粗"><a href="#2-加粗" class="headerlink" title="2. 加粗"></a>2. 加粗</h3><pre><code>**要设置为加粗的内容**（不要空格,星号可以用下划线_代替）</code></pre><p><strong>要设置为加粗的内容</strong>（不要空格,星号可以用下划线_代替）</p>
<h3 id="3-斜体加粗"><a href="#3-斜体加粗" class="headerlink" title="3. 斜体加粗"></a>3. 斜体加粗</h3><pre><code>显而易见咯，用三个* 包裹起来就行了. ***要设置为斜体加粗的内容***（不要空格,星号可以用下划线_代替）</code></pre><p><strong><em>要设置为斜体加粗的内容</em></strong>（不要空格,星号可以用下划线_代替）</p>
<h3 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4. 删除线"></a>4. 删除线</h3><pre><code>~~要添加删除线的内容~~（不要空格）</code></pre><p><del>要添加删除线的内容</del>（不要空格）</p>
<h2 id="三、-分隔线"><a href="#三、-分隔线" class="headerlink" title="三、 分隔线"></a>三、 分隔线</h2><pre><code>三个连续的星号、减号、下划线，都可以作为分隔行,但是这一行不能有其他的内容   ***   ---   ___</code></pre><hr>
<h2 id="四、-插入"><a href="#四、-插入" class="headerlink" title="四、 插入"></a>四、 插入</h2><h3 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h3><p>网上说用单引号&apos;单行代码&apos;包裹起来</p>
<p>&apos;&apos;&apos;<br>第一行代码<br>第二行代码（行数无限制）（三个引号单独占一行）<br>&apos;&apos;&apos;</p>
<p>但是好像不是很适用与md本身的一些代码，比如加粗之类的</p>
<p>于是还是用<strong>最简单直接的：在行首用tab或4个空格</strong>，申请一行不编译（可加行），背景色为深灰色，上面都是这种方式</p>
<h3 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a>2. 引用</h3><p>在一段的行首，使用大于号&gt;表明一个区块，后直接加内容就可以（不用空格），一个表示一级分区（好像无分区上限）</p>
<blockquote>
<p>区块1</p>
<blockquote>
<p>区块1.1</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>区块1.1.1.1.1.1.1.1.1.1</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="3-超链接"><a href="#3-超链接" class="headerlink" title="3. 超链接"></a>3. 超链接</h3><p><strong>超链接都是在当前界面打开，如果要在新界面打开，请使用html的a标签</strong></p>
<h4 id="3-1-行内式"><a href="#3-1-行内式" class="headerlink" title="3.1 行内式"></a>3.1 行内式</h4><pre><code>[超链接名字](超链接地址 &quot;optional title（选填，鼠标移动到到超链接上显示的内容）&quot;)

eg:
[朩的微博](heoah.com &quot;他的主页&quot;)</code></pre><p><a href="heoah.com" title="他的主页">朩的微博</a></p>
<h4 id="3-2-参考式"><a href="#3-2-参考式" class="headerlink" title="3.2 参考式"></a>3.2 参考式</h4><p>试了下好像没用..可能是博客或者代理用的md解析不一样吧</p>
<pre><code>[超链接名字][标号]
[标号]:超链接地址 / &quot;optional title（选填，鼠标移动到到超链接上显示的内容）&quot;

eg:
[朩的微博][1]
[1]:heoah.com</code></pre><h3 id="4-图片"><a href="#4-图片" class="headerlink" title="4. 图片"></a>4. 图片</h3><p>和本质上和超链接是一样的，在超链接前面加个！就行了</p>
<h4 id="4-1-引用地址为网址"><a href="#4-1-引用地址为网址" class="headerlink" title="4.1 引用地址为网址"></a>4.1 引用地址为网址</h4><p>本地图片获得URL：使用图床进行存储图片。简单点说：上传你的图片给网站，网站给你分配存储空间，针对每张图片给你一个url，你直接引用url。<br>github，gitee等都有图床服务，推荐 七牛云</p>
<h4 id="4-2-引用为本地图片"><a href="#4-2-引用为本地图片" class="headerlink" title="4.2 引用为本地图片"></a>4.2 引用为本地图片</h4><p>在_config.yml设置里面post_asset_folder设置为true</p>
<p>这样在每次new post时就会在生成md文件时，同时生成一个同名的文件夹</p>
<p>安装hexo-asset-image插件:</p>
<pre><code>npm install hexo-asset-imagine --save</code></pre><p>将图片放在文件夹，命名例如1.png</p>
<pre><code>![名字（点击后出现图片，一般留空）](md文件名/图片名)

eg:
![](index/1.png)</code></pre><h2 id="五、-表"><a href="#五、-表" class="headerlink" title="五、 表"></a>五、 表</h2><h3 id="1-列表"><a href="#1-列表" class="headerlink" title="1. 列表"></a>1. 列表</h3><p><strong>在列表内容里面引用代码，用Tab或者4个空格是不阔冷滴！因为都是在行首操作</strong></p>
<h5 id="1-1-无序列表"><a href="#1-1-无序列表" class="headerlink" title="1.1 无序列表"></a>1.1 无序列表</h5><p>在行首用符号进行定义</p>
<pre><code>+ 列表内容 （加号后必须要空格）（加号可以用减号- 乘号*代替）

eg:
+ 第三行
- 第二行
* 第一行</code></pre><ul>
<li>第三行</li>
</ul>
<ul>
<li>第二行</li>
</ul>
<ul>
<li>第一行</li>
</ul>
<h4 id="1-2-有序列表"><a href="#1-2-有序列表" class="headerlink" title="1.2 有序列表"></a>1.2 有序列表</h4><p>在行首用数字加小数点定义（数字一定要为非负整数）</p>
<pre><code>标号. 列表内容（小数点后必须要空格）

eg:
1. 如果你的序号为负数，那么会认为你的有序链表到此已经结束。
4. 第一行的序号很重要，定义了你列表的开始序号
8. 后面行的序号都是根据第一行数字递增1得到的</code></pre><ol>
<li>如果你的序号为负数，那么会认为你的有序链表到此已经结束。</li>
<li>第一行的序号很重要，定义了你列表的开始序号</li>
<li>后面行的序号都是根据第一行数字递增1得到的</li>
</ol>
<h4 id="1-3-组合列表"><a href="#1-3-组合列表" class="headerlink" title="1.3 组合列表"></a>1.3 组合列表</h4><p>也可以成为 列表嵌套</p>
<p>有序列表和无序列表可以随意组合嵌套，上一级和下一级之间用三个空格区别</p>
<pre><code>eg:
+ 一级无序
   1. 二级有序
+ 一级无序
   + 二级无序
1. 一级有序
   + 二级无序
2. 一级有序
   1. 二级有序</code></pre><ul>
<li>一级无序<ol>
<li>二级有序</li>
<li>二级有序</li>
</ol>
</li>
<li>一级无序<ul>
<li>二级无序</li>
<li>二级无序</li>
</ul>
</li>
</ul>
<ol>
<li>一级有序<ul>
<li>二级无序</li>
</ul>
</li>
<li>一级有序<ol>
<li>二级有序</li>
</ol>
</li>
</ol>
<h3 id="2-表格"><a href="#2-表格" class="headerlink" title="2. 表格"></a>2. 表格</h3><pre><code>表头|表头|表头        （自定义列数都可以）
:-|:-:|-:            （ - 表示内容）（：表示对齐方式，左边代表左对齐，右边代表右对齐，两边都有表示居中对齐）
内容|内容|内容

eg:
姓名|性别|年龄
:-|:-:|-:
张三|男|15
李四|女|16
王五|男|17</code></pre><table>
<thead>
<tr>
<th align="left">姓名</th>
<th align="center">性别</th>
<th align="right">年龄</th>
</tr>
</thead>
<tbody><tr>
<td align="left">张三</td>
<td align="center">男</td>
<td align="right">15</td>
</tr>
<tr>
<td align="left">李四</td>
<td align="center">女</td>
<td align="right">16</td>
</tr>
<tr>
<td align="left">王五</td>
<td align="center">男</td>
<td align="right">17</td>
</tr>
</tbody></table>
<h2 id="六、-小结"><a href="#六、-小结" class="headerlink" title="六、 小结"></a>六、 小结</h2><p>总的来说，使用Markdown语法确实比较简单，而且看起来更为美观。它兼容HTML格式，且由于它是纯文本，跨平台性也更好。</p>
<p>段落前后要求有空行（无文字内容）</p>
<p>看起来大方简洁，直观舒服。设置字体颜色还是用font（虽然我老感觉这是HTML语法）</p>
<p><font size=2 color="00AAAA">但是我还是不喜欢用，噜啦啦啦啦啦(//∇//)！因为它显得太松散了，其中一部分功能可能会用，但更多可能还是喜欢直接用html</font></p>
]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo使用</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo撰文1</title>
    <url>/Hexo%E5%8D%9A%E5%AE%A2/2020/1/</url>
    <content><![CDATA[<p>此文效果全部用Html</p>
<p style = "background: PowderBlue;text-align: center;">博客撰文</p>

<p style = "font-size: 25px">
（猜测：对于md文件中的每一行文字，文章解析时会以回车符分隔，一个回车符代表看做一串文字结束，用一个&lt;p&gt;来存储，放进html中。如果添加了html标签，对于回车符，好像就不能判断了，所有文字将展示为一行，只能自己手动用&lt;br&gt;进行空行）<br>
其实是md语法对html内容不生效，只要遵循md的段落规则就可以实现md兼容html（段落之间用空行分隔），不用手动br<br>
此处，主要思想：在md里添加html标签，标签内嵌css</p>
<a id="more"></a>
<font size=4 color="red">大小、颜色与样式：</font>
用"&lt;font size=4 color="red"&gt;&lt;/font&gt;"（效果为“大小、颜色与样式”）<br>
可以设置字体的大小（默认为3，可为小数）；颜色（可以使用取色板颜色“#FFFFFF”或者“red”“blue”等）；样式（属性名为face）<br>
<font size=4 color="red">背景、居中与样式等：</font>
如果想修改更多属性，比如字体款式、背景颜色。建议自己定义一个&lt;p&gt;或者&lt;span&gt;&lt;li&gt;等标签（他们结束后，会自动产生一个回车符。后面加的一行文字就到下一行啦）<br>
使用<a href="https://www.w3school.com.cn/html/html_styles.asp" target="_blank" rel="noopener">style</a>属性来修改（font比较方便，但是功能有限，style属性淘汰了旧的font属性）<br>
&lt;p style = "background: PowderBlue;text-align: center;"&gt;（效果为“博客撰文”）<br>
<font size=4 color="red">特殊字符：</font>如果想打这五个符号&quot; &apos; &amp; &lt; &gt;请记住，一定要用<a href="https://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">符号实体</a>。<br>
常用六个：
<li>&amp;quot;表示&quot;（双引号）</li>  
<li>&amp;apos;表示&apos;（单引号）</li> 
<li>&amp;amp;表示&amp; </li> 
<li>&amp;lt;表示&lt;（小于号）</li>  
<li>&amp;gt表示&gt;（大于号）</li> 
<li>&amp;nbsp;表示空格（连续的空格符号会被解析为一个，所以要连续空格需要用实体名）</li> 
<br>
<font size=4 color="blue">注意font和style的区别：</font>
<li>font里的属性为size，color，对应的值用=</li>
<li>sytle是属性的集合，要用style=""。属性名与属性值的对应用冒号: 属性间用分号分隔; 。font-size要使用px（像素）作为单位</li>
<p style = "background: PowderBlue;text-align: center;">结束啦</p><br>

<p style = "background: #00AAAA;text-align: center;">引用</p>
最为常见的引用也就是链接网址和插入图片了，链接网址比较容易，直接用&lt;a href=""&gt;就可以了。这里主要讲插入图片<br>
插入图片直接用&lt;img src=""&gt;当然是没有问题的，但是要注意：<font size=3 color="red">插入的图片路径怎么写？</font><br>
我在source文件夹下建立了一个名为img的文件夹专门存放图片<br>
<li>主界面显示：由于文章的当前根目录为source文件夹，要读取下面的文件，直接src="img/1.png"就可以了</li>
<li> 注意！如果图片路径直接写上面的那个，打开文章就会发现，图片无法显示“Not found in ***/***/”这时候就要关注_config.yml中的一个设置permalink:</li>
<li>所谓的permalink，也就是文章的永久地址（设置格式参考Hexo说明），我的设置为 :category/:year/:id/ （分类，年，ID）。分为三层（层数很重要）</li>
<li>文章界面显示：<font size=2.5 color="red">在文章界面，此时的根目录不再是source了</font>，而是文章的permalink。所以，要链接到图片，就先要返回到source目录，由于我设置的是三层，所以应该../三次（返回上层目录）才能回到根目录</li>
<li><font size=3 color="red">于是，最终的src="../../../img/1.png"（../的个数和permalink层数有关，img下创建文件夹也是可以的）</font></li>]]></content>
      <categories>
        <category>Hexo博客</category>
      </categories>
      <tags>
        <tag>Hexo使用</tag>
      </tags>
  </entry>
  <entry>
    <title>图的连通</title>
    <url>/PAT/2020/A1013/</url>
    <content><![CDATA[<p><font size=4 color="red">没画示意图，美图镇楼</font><br>有向图、无向图与连通性、连通分量、连通图</p>
<a id="more"></a>

<p style = "background: PowderBlue;text-align: center;">无向图</p>

<p><font size=4>1.连通性</font><br>两个顶点vi与vj之间可以互相到达（直接连通或者其他点作为中间点连通），即称为这两个点连通<br><font size=4>2.连通图</font><br>如果一个图里面的任意两个顶点vi和vj都可以互相到达，即称这个无向图为连通图<br><font size=4>3.连通分量</font><br>无向图G的极大连通子图称为G的连通分量。</p>
<ul>
<li>连通图只有一个连通分量，就是它本身</li>
<li>非连通图有多个连通分量</li>
<li><strong>一个有n个连通分量的无向图只用添加n-1个边就能成为连通图</strong></li>
</ul>
<p style = "background: PowderBlue;text-align: center;">结束啦</p>

<p style = "background: #00AAAA;text-align: center;">有向图</p>

<ul>
<li>与无向图定义相同，“强”针对于有向图</li>
<li><strong>n强连通分量的DiG成为强连通图最少添加边不一定是2n</strong></li>
</ul>
<p style = "background: #00AAAA;text-align: center;">结束啦</p>

<img src="../../../img/PAT/1.png">]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图论</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title>博客雏形</title>
    <url>/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/2020/1/</url>
    <content><![CDATA[<p>太不容易了TAT<br>花了一整天时间，终于搭建好了一个博客雏形，node.js + git + hexo结构，用github + gitee代理并国内外分流<br>主题采用大佬写的ayer（简单点来说，大佬做好了一切，我抄了这么久…..）</p>
<a id="more"></a>
<p style = "background: PowderBlue;text-align: center;">遇到了几个坑：</p>
1、nodejs:<br>
    由于node.js是以前配置的，可能没有配置好。导致在hexo下载后，init一直失败，报错async remove(item)<br>网上说现在国内的hexo源有问题，但是我换了好几个源还是没有解决问题。最后才想到是不是node.js配置有问题或者是版本太低，于是就去官网下载了最新版的Nodejs
    （注意！Windows版本不能使用命令升级nodejs，只能去官网下载最新版本，然后同目录覆盖安装）<br>
    下载完之后就成功hexo init了<br>
2、hexo不解释三连：<br>
    在init成功后，我去换了ayer主题，然后开开心心地去看自己的网页~~~发现......<br>
    不仅主题没换，甚至我的title，author什么的都没换！！！<br>
    心态爆炸！！！<br>
    然后处理了好久才知道...我看的是github上代理的网站，我的修改在本地，还没上传.....<br>
    于是深深记住了不解释连招：hexo clean（清除缓存) hexo g（generate，也就是继承） hexo d（deploy 部署）<br>
    再去github的代理商看，好了，我真机智<br>
3、本地修改：<br>
    机智个锤子哦！<br>
    为什么要每次都部署到网站再去看成效？？？直接在本地看，它不香吗？<br>
    于是，再开一个git bash，把hexo server挂着<br>
    用另一个git bash进行其他操作，打开localhost:4000，之后的修改刷新就能看见了<br>
4、分流:<br>
    虽然github代理这一步完成得还是比较顺利，但是测试起来，这网速....确实不敢恭维<br>
    （导致还去用vps配了个ss翻墙，网速同样不敢恭维，延迟一般在100-200ms，但是进网站加载速度太慢，看油管都费劲。不过还好，我主要用来下东西，它下载速度还挺令我开心，现在下的都是1s内完成，预测速度40+m/s）<br>
    然后看教程，推荐分流代理，国内有coding，gitee用得比较多。coding跳转有广告，交钱或者给他打宣传就可以省去广告<br>
    于是国内选择了gitee<br>
5、gitee：<br>
    使用了gitee后，又被坑了....<br>
    第一个：秘钥...原来，秘钥还有公用和私用啊...添加的秘钥在gitee里，默认是公用（只能看），但是右上角有提示去添加私用的（能读能写）<br>
    第二个：说好的仓库名随便的！结果仓库名和Pages服务有关，如果和用户名不一样，又要配置什么root之类的。<br>
    开始傻乎乎的把Pages服务的url复制上去了，然后只有index传上去了，外联的图片、css和js什么都没，又傻了。<br>
    结果将仓库名和存储地址改为用户名，relo地方写仓库的pull的SSH就好了<br>
    <font color=red size=3>注意：每次的gitee部署完之后，要去gitee的Pages里面手动更新一下</font><br>
<p style = "background: PowderBlue;text-align: center;">上一部分结束啦</p>
现在博客字体什么的又不太熟悉了，还得去看看css和html教程咯]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>纪念</tag>
      </tags>
  </entry>
</search>
